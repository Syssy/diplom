%implementierung.tex

\chapter{Implementierung}
\label{chapter:imp}
\todo{Kapitel Implementierung schreiben}

\section{Simulation der Modelle}
Zur Simulation der beiden Modelle wurde Python (Python3) verwendet.

Abhängigkeiten von Numpy(Arrays zur schnelleren Verarbeitung), Scipy (Berechnung von Peakdaten) und PyPlot (graphische Darstellung) 

Mit der 3-s kann auch 2p simuliert werden, indem nicht benötigte Übergangswahrscheinlichkeiten auf 0 gesetzt werden. Die reine 2p-Simulation ist aber deutlich schneller, da nur auf boolschen Werten gearbeitet werden muss.

\subsection{Festlegung der Einheiten}
$20$ cm entspricht 200000 Schritten, in die MCC unterteilt wird.
1 Schritt ist damit $1$\,\textmu m
Trägergas hat nach etwa $0,1$ Sekunden die Säule durchlaufen.
Eine Zeiteinheit entspricht demnach ca. 0.1/200000 Sekunden 0.0000005s 0.0005ms $0,5$\,\textmu s


\subsection{Step-by-step}
Es kann entweder jeder Zeitschritt der Chromatographie simuliert und dabei für jedes Teilchen entschieden werden, ob es sich bewegt. Dabei angenommen, dass die Wahrscheinlichkeit der Wechselwirkung unabhängig vom aktuellen Ort oder dem Zeitpunkt des letzten Phasenwechsels ist. Es wird für jedes Teilchen festgehalten, wo es sich befindet und ähnlich wie bei der echten Chromatographie beobachtet, wann wie viele Teilchen die Säule durchquert haben. 
\todo{Stey by step-Simulation beschreiben}

\subsection{By-Event}
Bei Übergangswahrscheinlichkeiten, die sehr groß oder klein sind, kommt es selten zu Zustandsänderungen, sodass es in diesem Fall effizienter ist, eine Wartezeitmethode zu nutzen: Es wird für jedes Teilchen entschieden, wann es den Zustand wechselt und, falls es mobil ist, wie weit es bis dahin weiter wandert. Es werden also nur die tatsächlichen Ereignisse simuliert, Schritte für Zeitpunkte, zu denen nichts passiert, entfallen.
\todo{by event-simulation beschreibe,}

% Generelles: Welche Sprachen, warum (?)
% Die Simulation in Python, beide Varianten (Also by-event und step-by-step) 
% -> Algorithmen?

\section{Simulation des PAA}
Die Berechnung des PAA existiert in Java, dabei Referenz auf mosdi (Zitiere Paper, in dem das vorgestellt wird und sage, dass ich das verwende)
\todo{Implementierung des PAA beschreiben; erst wenn evtl nachprogrammierung fertig}
da allerdings zu langsam: abgespeckte version nachprogrammiert in julia

Warum Julia? 

Was kann meine PAA-Version und was nicht?

Laufzeitvergleich bei gleichen Ergebnissen

Nachbearbeitung der Ergebnisse wieder in Python



