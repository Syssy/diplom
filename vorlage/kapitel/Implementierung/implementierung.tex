%implementierung.tex

\chapter{Implementierung}
\label{chapter:imp}
\todo{Kapitel Implementierung schreiben}
\todo{Soll hier auch erwähnt werden, wie die verschiedenen Auswertungen gemacht wurden? Plots etc}

Aufrufe der wichtigen Funktionen (der Simulationen) Kommandozeilenparameter mit angeben. 


\section{Teilchensimulation}
Zur Simulation der beiden Modelle wurde Python (Python3) verwendet.

Abhängigkeiten von Numpy (Arrays zur schnelleren Verarbeitung), Scipy (Berechnung von Peakdaten) und PyPlot (graphische Darstellung) sowie statsmodels (für die qq-Plots)

Sowohl bei der Umsetzung der Step-by-Step Methode als auch By-Event kann mit der Implementierung des 3-Zustände Modells auch das 2-Zustände Modell simuliert werden, indem nicht benötigte Übergangswahrscheinlichkeiten auf einen Wert von $0$ gesetzt werden. Die 2-Zustände Simulation ist aber vor allem bei der Step-by-Step Implementierung deutlich schneller, da nur auf boolschen Werten gearbeitet werden muss und deutlich weniger ungenutzte Information in den Zwischenschritten berechnet wird.


\subsection{Step-by-step}

Im Laborexperiment wird nur in gewissen Intervallen die Ankunft von Teilchen detektiert, bei der MCC-IMS-Kopplung wird beispielsweise nur zwei Mal pro Sekunde eine Messung durchgeführt. Daher genügt es auch in der Simulation, wenn nicht nach jedem Simulationsschritt die Orte aller Teilchen getestet werden, um ein ausreichend exaktes Ergebnis zu erhalten.
Es können also zunächst viele Simulationsschritte durchgeführt werden, bevor getestet wird, ob Teilchen die Länge $l$ erreicht haben. Nach den oben angegebenen Einheiten können so zwischen jedem Test $50$ Simulationsschritte erfolgen, was $0,5 s$ entspricht. Dadurch entfallen viele Abfragen und es kann Simulationszeit eingespart werden. 

Da außerdem klar ist, dass frühestens nach $l$ Schritten Teilchen überhaupt die Säule durchlaufen haben können, muss vor diesem Zeitpunkt auch kein Test auf Erreichen der Länge durchgeführt werden, wodurch weitere Zeit eingespart werden kann.
\todo{wie viel Zeit ist das jeweils? ist das interssant?}


\subsection{By-Event}
%Bei Übergangswahrscheinlichkeiten, die sehr groß oder klein sind, kommt es selten zu Zustandsänderungen, sodass es in diesem Fall effizienter ist, eine Wartezeitmethode zu nutzen: Es wird für jedes Teilchen entschieden, wann es den Zustand wechselt und, falls es mobil ist, wie weit es bis dahin weiter wandert. Es werden also nur die tatsächlichen Ereignisse simuliert, Schritte für Zeitpunkte, zu denen nichts passiert, entfallen.
%\todo{by event-simulation beschreiben -> Methoden}
???

\subsection{Vergleich von Step-by-Step und By-Event}
Die aus den beiden Simulationsarten resultierenden Peaks sind (natürlich) gleich. Der Laufzeitvergleich hängt stark von den gewählten Parametern ab, außerdem gibt es gravierende Unterschiede zwischen dem 2- und 3-Zustände Modell.

Bei der Simulation den 2-Zustände Modells ist die Step-by-Step Variante für die meisten Parameterkombinationen deutlich schneller, als die By-Event Implementierung. Der große Vorteil von Step-by-Step liegt hier in der Verwendung von booleschen Werten und Nutzung von Numpy-Arrays, auf welchen die Ausführung logischer Operationen parallel erfolgen kann. Lediglich einem sehr großen Wert für $p_{\text{m}}$, ab etwa $0.99$ ist die By-Event Variante geringfügig schneller. Das liegt daran, dass in diesen Fällen besonders selten Ereignisse erzeugt werden müssen und sich die Teilchen in großen Sprüngen forbewegen können. 

Für die 3-Zustände Simulation müssen jedoch in der Step-by-Step Implementierung sehr viele Einträge für die Hilfsarrays erzeugt werden, die jedoch für die Berechnung der neuen Arrays nicht benötigt werden. Durch diese überflüssigen Berechnungen verliert die Step-by-Step Implementierung ihren Vorteil gegen über der By-Event Variante, sodass diese schneller wird. Dies wird deutlicher, je größer $p_{\text{mm}}$ wird.

%Bei Parametern nah an $1$ lohnt meist die Nutzung der By-Event Implementierung, da dann nur seltener Ereignisse erzeugt werden und viele Schritte in denen nichts passiert, also kein Zustandswechsel stattfindet, übersprungen werden können.
%Bei sehr vielen Teilchen lohnt sich eher die Step-by-Step Variante, da die Teilchen, die in Numpy-Arrays als boolesche Werte vorliegen, sehr viel schneller verarbeitet werden können, als die Listen, die bei der Event -Variante verwendet werden. Eine weitere Parallelisierung scheint hier aber nicht zu lohnen
%Zumindest bei Parametern extrem nah bei 1 kann sich die Laufzeit der By-Event stark vergrößern, wenn die Säule zu kurz ist, da die Teilchen ``viel zu weit über das Ziel hinausschiessen'', aber das erst später festgestellt wird, wenn das Teilchen wieder betrachtet wird und schon entsprechend viele Zeitschritte vergangen sind. 

% Generelles: Welche Sprachen, warum (?)
% Die Simulation in Python, beide Varianten (Also by-event und step-by-step) 
% -> Algorithmen?

\section{Simulation des PAA}
Die Berechnung des PAA existiert in Java, dabei Referenz auf mosdi (Zitiere Paper, in dem das vorgestellt wird und sage, dass ich das verwende)

In der Hoffnung, Laufzeit einzusparen durch eine eingeschränkte Version des PAA und Nutzung von Julia, wurde eine eigene Implementierung entwickelt.

%(laufzeit linear/quadratisch oder so in irgendwas? noch mal bei mosdi nachgucken) länge sowieso beschränkt durch länge der säule (?????) und nicht durch maximale wartezeit

Warum Julia? 

Laufzeitvergleich bei gleichen Ergebnissen

Die Nachbearbeitung der Ergebnisse des PAA wurde wiederum in Python implementiert.


