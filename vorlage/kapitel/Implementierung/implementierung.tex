%implementierung.tex

\chapter{Implementierung}
\label{chapter:imp}
\todo{Kapitel Implementierung schreiben}
\todo{Soll hier auch erwähnt werden, wie die verschiedenen Auswertungen gemacht wurden? Plots etc}

Aufrufe der wichtigen Funktionen (der Simulationen) Kommandozeilenparameter mit angeben. 


\section{Teilchensimulation}
Für die Teilchensimulation wurden die Algorithmen \ref{algo_by_Step} und \ref{algo_by_event} jeweils für zwei und drei Zustände implementiert. Dafür wurde Python 3.4 verwendet. 
Um insbesondere bei der Step-by-Step Implementierung eine schnelle Verarbeitung der Zustands- und Ortsarrays zu gewährleisten, wurden dafür NumPy-Arrays verwendet. Außerdem stellt NumPy Methoden zur Berechnung von Percentilen, geometrisch verteilte Zufallszahlen und Bestimmung der Position des größten Wertes einer Liste zur Verfügung, welche für die Implementierung genutzt wurden.
Für die graphische Ausgabe der Peaks und weitere geplottete Darstellungen im Bereich der Auswertung der Simulationen wurde PyPlot genutzt.

% Zur Simulation der beiden Modelle wurde Python 3.4 verwendet. Dabei existieren Abhängigkeiten von NumPy (Arrays zur schnellen Verarbeitung), SciPy (Berechnung von Peakdaten) und PyPlot (graphische Darstellung)

Die Datei \texttt{simulation.py} enthält alle Funktionen zur Simulation und Berechnung der Peakdaten. Wichtigster Bestandteil ist die abstrakte Klasse \texttt{Simulation} und die zwei Unterklassen \texttt{Simulation\_2s} und \texttt{Simulation\_3s}. Wie im vorherigen Kapitel gesehen, unterscheiden sich sowohl bei der Step-by-Step, als auch bei der By-Event Variante die Algorithmen nur durch die Umsetzung eines Berechnungsschrittes, sodass die Methoden zur Simulation eines Berechnungsschrittes bzw. Events in der Superklasse abstrakt sind und jeweils für das Modell passend in den Unterklassen implementiert wurden. In der Klasse \verb!Simulation_3s! sind zusätzlich auch die Vorberechnungen für die kumulierte Parametermatrix der Step-by-Step Simulation und die Wechselmatrix der By-Event Simulation zu finden.

Um eine Simulation zu starten, wird zunächst eine Instanz der Simulationsklasse erstellt

TODO

In der Datei \texttt{plottings} sind mehrere verschiedene Möglichkeiten zur Auswertungen der Simulation enthalten, die unter Anderem auch verwendet wurden, um die Darstellungen in Kapitel \ref{chapter:eva} zu erstellen. 

Die Dateien \verb!2s_simulate_and_plot.py! sowie  \verb!3s_simulate_and_plot.py! sind für das Starten der Simulationen und Plotten der Ergebnisse durch den Benutzer gedacht. Durch den Aufruf mit einigen Kommandozeilenparametern kann zunächst ein vordefinierte Menge an Parameterkombinationen zur Simulation ausgewählt werden. 
Mit dem Parameter \texttt{-p} wird eine Menge von Parameterkombinationen ausgewählt. Zur Verfügung stehen dabei für das 2-Zustände Modell und das 3-Zustände Modell 3a jeweils \textit{small\_set}, \textit{medium\_set} und \textit{large\_set}, außerdem können mittels \textit{random} zufällige Kombinationen erstellt werden, die Anzahl dieser zufälligen Kombinationen wird über den Parameter \texttt{-cn} festgelegt. Außerdem steht für das 2-Zustände Modell noch die Kombination \textit{skew} zur Verfügung, die tailing erzeugende Parameter enthält.

Der Parameter \texttt{-a} wählt den gewünschten Ansatz, also \texttt{-a=S} für die Step-by-Step Simulation und \texttt{-a=E} für die By-Event Simulation.

Mit den Parametern \texttt{-n} und \texttt{-l} können Anzahl der Teilchen und Länge der Säule eingegeben werden. Als Default-Werte dafür sind $1000$ Teilchen und eine Länge von $1000$ Schritten vorgesehen.

Um einen einzelnen Peak zu Plotten, kann mittels \texttt{-pp} die gewünschte Parameterkombination aus $ps$ und $pm$ eingegeben werden. Für die 2-Zustände Simulation würde beispielsweise der Aufruf \verb!python3 2s_simulate_and_plot.py -pp 0.999 0.5! eine Simulation mit den Parametern $ps = 0.999$ und $pm = 0.5$ erstellen, diese simulieren, falls sie noch nicht vorhanden ist und anschließend eine graphische Darstellung des Peaks ausgeben. 
Für die 3-Zustände Simulation ist das Modell 3a als Voreinstellung gewählt, damit kann eine Parameterkombination aus pmm, pml, paa und pll eingegeben werden. Um das gesamte 3-Zustände Modell auszunutzen, ist die Auswahl \texttt{-m=3s} nötig, und die Eingabe aller neun Parameter. 

Weitere Kommandozeilenparameter erlauben die Auswahl der gewünschten Plots.


Sowohl bei der Umsetzung der Step-by-Step Methode als auch By-Event kann mit der Implementierung des 3-Zustände Modells auch das 2-Zustände Modell simuliert werden, indem nicht benötigte Übergangswahrscheinlichkeiten auf einen Wert von $0$ gesetzt werden. Die 2-Zustände Simulation ist aber vor allem bei der Step-by-Step Implementierung deutlich schneller, da nur auf boolschen Werten gearbeitet werden muss und deutlich weniger ungenutzte Information in den Zwischenschritten berechnet wird.


\subsection{Step-by-step}

Im Laborexperiment wird nur in gewissen Intervallen die Ankunft von Teilchen detektiert, bei der MCC-IMS-Kopplung wird beispielsweise nur zwei Mal pro Sekunde eine Messung durchgeführt. Daher genügt es auch in der Simulation, wenn nicht nach jedem Simulationsschritt die Orte aller Teilchen getestet werden, um ein ausreichend exaktes Ergebnis zu erhalten.
Es können also zunächst viele Simulationsschritte durchgeführt werden, bevor getestet wird, ob Teilchen die Länge $l$ erreicht haben. Nach den oben angegebenen Einheiten können so zwischen jedem Test $50$ Simulationsschritte erfolgen, was $0,5 s$ entspricht. Dadurch entfallen viele Abfragen und es kann Simulationszeit eingespart werden. 

Da außerdem klar ist, dass frühestens nach $l$ Schritten Teilchen überhaupt die Säule durchlaufen haben können, muss vor diesem Zeitpunkt auch kein Test auf Erreichen der Länge durchgeführt werden, wodurch weitere Zeit eingespart werden kann.
\todo{wie viel Zeit ist das jeweils? ist das interssant?}


\subsection{By-Event}
%Bei Übergangswahrscheinlichkeiten, die sehr groß oder klein sind, kommt es selten zu Zustandsänderungen, sodass es in diesem Fall effizienter ist, eine Wartezeitmethode zu nutzen: Es wird für jedes Teilchen entschieden, wann es den Zustand wechselt und, falls es mobil ist, wie weit es bis dahin weiter wandert. Es werden also nur die tatsächlichen Ereignisse simuliert, Schritte für Zeitpunkte, zu denen nichts passiert, entfallen.
%\todo{by event-simulation beschreiben -> Methoden}
???

\subsection{Laufzeitvergleich von Step-by-Step und By-Event}

Die Laufzeit einer Simulation hängt stark von den gewählten Parametern ab, außerdem gibt es gravierende Unterschiede zwischen dem 2- und 3-Zustände Modell.

In Tabelle \ref{2s_laufzeit} ist eine Übersicht über die Laufzeiten der verschiedenen Simulationsarten gegeben. 
Jede Zeile enthält die Zeiten für die gegebenen Parameter, jede Spalte entspricht einer Simulationsart. Dabei steht ``S'' für die schrittweise und ``E'' für die ereignisbasierte Simulation, die Zahl dahinter gibt die Anzahl der simulierten Teilchen an.

Die Zeiten wurden unter jeweils gleichen Bedingungen gemessen und sind in Sekunden angegeben. Mit einem $*$ gekennzeichnete Zeiten deuten an, dass die Simulationen nach Erreichen der maximalen Anzahl Simulationsschritte beendet wurden, also keinen vollständigen Peak innerhalb dieses Zeitraumes liefern.

\begin{table}[h]
\centering
\caption{Laufzeitvergleich für die 2-Zustände Simulation}
\label{2s_laufzeit}
\begin{tabular}{|l|l||l|l|l|l|l|l|l|} \hline
ps     & pm   & S,$1000$ & E,$1000$ & S,$10.000$ & E,$10.000$ & PAA & PAA* & MoSDi \\ \hline \hline
$0,997  $ & $ 0,01 $ & $ 8,4  $ & $ 20,9 $ & $ 47,4  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,997  $ & $ 0,3  $ & $ 6,1  $ & $ 15,4 $ & $ 33,7  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,997  $ & $ 0,6  $ & $ 3,6  $ & $ 8,9 $ & $ 19,4  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,997  $ & $ 0,95 $ & $ 0,6  $ & $ 1,3 $ & $ 2,6   $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,999  $ & $ 0,01 $ & $ 25,5 $ & $ 40,2 $ & $ 142,7 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,999  $ & $ 0,3  $ & $ 18,6 $ & $ 27,8 $ & $ 100,4 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,999  $ & $ 0,6  $ & $ 11,0 $ & $ 16,1 $ & $ 57,8  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,999  $ & $ 0,95 $ & $ 1,7  $ & $ 2,2 $ & $ 7,6   $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9993 $ & $ 0,01 $ & $ 37,6 $ & $  $ & $ 204,1 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9993 $ & $ 0,3  $ & $ 26,6 $ & $  $ & $ 143,4 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9993 $ & $ 0,6  $ & $ 15,3 $ & $  $ & $ 82,6  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9993 $ & $ 0,95 $ & $ 2,3  $ & $  $ & $ 10,8  $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9996 $ & $ 0,01 $ & $ 59,9*$ & $  $ & $ 341,2 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9996 $ & $ 0,3  $ & $ 46,2 $ & $  $ & $ 252,6 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9996 $ & $ 0,6  $ & $ 26,7 $ & $  $ & $ 150,2 $ & $  $ & $  $ & $ $ & $  $\\ \hline
$0,9996 $ & $ 0,95 $ & $ 4,1  $ & $  $ & $ 18,8  $ & $  $ & $  $ & $ $ & $  $\\ \hline
\end{tabular}
\end{table}

Wie zu erwarten war, steigt die Laufzeit an, je größer ps und je kleiner pm ist. Das liegt offensichtlich an der Abbruchbedingung des Algorithmus, der terminiert, wenn alle Teilchen über die gesamte Strecke von $ell$ Schritten simuliert wurden. Simulationsparameter mit kleinem ps oder großem pm sorgen für weniger Verweilen der Teilchen im stationären Zustand und damit eine schnelle Passage der Strecke, wodurch die die Simulationsdauer kürzer wird. 

Bei der Simulation den 2-Zustände Modells ist die Step-by-Step Variante für die meisten Parameterkombinationen deutlich schneller, als die By-Event Implementierung. Der große Vorteil von Step-by-Step liegt hier in der Verwendung von booleschen Werten und Nutzung von NumPy-Arrays, auf welchen die Ausführung logischer Operationen sehr schnell erfolgen kann. Lediglich einem sehr großen Wert für $p_{\text{m}}$, ab etwa $0.99$ ist die By-Event Variante geringfügig schneller. Das liegt daran, dass in diesen Fällen besonders selten Ereignisse erzeugt werden müssen und sich die Teilchen in großen Sprüngen forbewegen können. 


\begin{table}[h]
\centering
\caption{Laufzeitvergleich für die 3-Zustände Simulation}
\label{3s_laufzeit}
\begin{tabular}{|l|l|l|l||l|l|l|l|l|l|l|}
\hline
pmm & pml & paa & pll & S,$1000$ & E,$1000$ & S,$10.000$ & E,$10.000$ & PAA & PAA* & MoSDi \\ \hline \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,00005$ & $0,9996$ & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,00005$ & $0,9996$ & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,003 $  & $0,997$  & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,003 $  & $0,997$  & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,003 $  & $0,9996$ & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,01 $ & $0,003 $  & $0,9996$ & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,003 $  & $0,997$  & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,003 $  & $0,997$  & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,003 $  & $0,9996$ & $0,99995$  & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
$ 0,9  $ & $0,003 $  & $0,9996$ & $0,999995$ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ & $ $ \\ \hline
\end{tabular}
\end{table}
Für die 3-Zustände Simulation müssen jedoch in der Step-by-Step Implementierung sehr viele Einträge für die Hilfsarrays erzeugt werden, die jedoch für die Berechnung der neuen Arrays nicht benötigt werden. Durch diese überflüssigen Berechnungen verliert die Step-by-Step Implementierung ihren Vorteil gegen über der By-Event Variante, sodass diese schneller wird. Dies wird deutlicher, je größer $p_{\text{mm}}$ wird.
%Bei Parametern nah an $1$ lohnt meist die Nutzung der By-Event Implementierung, da dann nur seltener Ereignisse erzeugt werden und viele Schritte in denen nichts passiert, also kein Zustandswechsel stattfindet, übersprungen werden können.
%Bei sehr vielen Teilchen lohnt sich eher die Step-by-Step Variante, da die Teilchen, die in NumPy-Arrays als boolesche Werte vorliegen, sehr viel schneller verarbeitet werden können, als die Listen, die bei der Event -Variante verwendet werden. Eine weitere Parallelisierung scheint hier aber nicht zu lohnen
%Zumindest bei Parametern extrem nah bei 1 kann sich die Laufzeit der By-Event stark vergrößern, wenn die Säule zu kurz ist, da die Teilchen ``viel zu weit über das Ziel hinausschiessen'', aber das erst später festgestellt wird, wenn das Teilchen wieder betrachtet wird und schon entsprechend viele Zeitschritte vergangen sind. 

% Generelles: Welche Sprachen, warum (?)
% Die Simulation in Python, beide Varianten (Also by-event und step-by-step) 
% -> Algorithmen?

\section{Simulation des PAA}
Die Berechnung des PAA existiert in Java, dabei Referenz auf mosdi (Zitiere Paper, in dem das vorgestellt wird und sage, dass ich das verwende)

In der Hoffnung, Laufzeit einzusparen durch eine eingeschränkte Version des PAA und Nutzung von Julia, wurde eine eigene Implementierung entwickelt.

%(laufzeit linear/quadratisch oder so in irgendwas? noch mal bei mosdi nachgucken) länge sowieso beschränkt durch länge der säule (?????) und nicht durch maximale wartezeit

Warum Julia? 

Laufzeitvergleich bei gleichen Ergebnissen

Die Nachbearbeitung der Ergebnisse des PAA wurde wiederum in Python implementiert.


