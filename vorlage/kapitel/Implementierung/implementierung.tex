\chapter{Implementierung}
\label{chapter:imp}

Zur Simulation der Modelle wurde die Software MCC-Sim entwickelt. \todo{Hinweis auf CD?}
Sie ist unterteilt in zwei Bereiche, die Teilchensimulation und die Simulation des PAA.

struktur:
Software: MCC-Sim 
Unterteilung in Teilchen/Paa (?)

Teilchen: erst benutzersicht:
die drei dateien simulation.py, sim2s sim3s getrennt, wobei das zweite dann halt kürzer wird
anschließend internes wie die Sim -Klasse


\section{Teilchensimulation/MCC-Sim}


\subsection{Anwendungen}
Die für die Teilchensimulation zur Verfügung stehenden Anwendungen sind \texttt{simulation.py}, \verb!2s_simulate_and_plot.py! sowie  \verb!3s_simulate_and_plot.py!. Diese wurden in Python 3.4 implementiert \footnote{http://python.org} und werden im Folgenden vorgestellt.

\paragraph{\texttt{simulation.py}}

Durch den Aufruf von \texttt{simulation.py} können einzelne Simulationen gestartet und deren Ergebnisse angezeigt werden.
Die Parameter für die Simulation werden dabei über Kommandozeilenparameter eingegeben. Erster Parameter ist dabei das gewünschte Modell, es besteht die Auswahl zwischen \texttt{2s}, \texttt{3s} und \texttt{3a}, danach müssen Simulationsparameter eingegeben werden. Für das 2-Zustände Modell sind dies ps und pm. Für das allgemeine 3-Zustände Modell wird die Übergangsmatrix \ref{3s_Transit} als Liste der neun Parameter \verb!pmm,pma,pml,pam,paa,pal,plm,pla,pll! übergeben. Wird das Modell 3a ausgewählt, können auch nur die vier nötigen Parameter \verb!pmm,pml,paa,pll! übergeben werden.
Die Simulationsart wird über den Kommandozeilenparameter \texttt{-a} ausgewählt, dabei stehen \texttt{E} für die By-Event Simulation und \texttt{S} für die Step-by-Step Simulation zur Auswahl.
Ein Aufruf
\begin{verbatim}
python3 simulation.py 3a 0.5 0.0001 0.9993 0.99999 -a S
\end{verbatim}
startet beispielsweise eine schrittweise Simulation des 3-Zustände Modells 3a mit den Parametern $pmm = 0,5$, $pml = 0,0001$, $paa = 0,9993$ und $pll = 0,99999$. Als Ergebnis der Simulation wird anschließend eine Liste von Ankunftszeiten der simulierten Teilchen, sowie die daraus berechneten Peakdaten angezeigt. Eine weitere Ausgabeoptionen ist \texttt{-p}, womit zusätzlich eine graphische Darstellung der Ankunftszeiten in Form eines Histogramms angezeigt wird.

Als Standard für die Simulationen werden eine Säulenlänge von $1000$ Einheiten, ein Zeitraum von $240$s und $1000$ zu simulierende Teilchen angenommen. Diese Einstellungen können über die Parameter \texttt{-n} (Anzahl der Teilchen), \texttt{-l} (Länge der Säule) und \texttt{--mt} (Maximalzeit) verändert werden.
Der Aufruf
\begin{verbatim}
python3 simulation.py 2s 0.9999 0.01 -a E -n 10000 --mt 400
\end{verbatim}
startet daher eine ereignisbasierte Simulation im 2-Zustände Modell, bei der $10.000$ Teilchen über einen Maximalzeitraum von $400$ Sekunden simuliert werden.

%Da zur Evaluation 
%Um es zusätzlich zu dieser Möglichkeit, jeweils eine Simulation zu starten, zu ermöglichen, die Ergebnisse aus vielen Simulationen 

\paragraph{\texttt{2s\_simulate\_and\_plot.py}}
Diese Anwendung erlaubt es für das Modell mit zwei Zuständen, viele Simulationen zu starten und deren Ergebnisse durch verschiedene Plots darzustellen. Die Ergebnisse der einzelnen Simulationen werden dafür abgespeichert und stehen damit auch späteren Auswertungen zur Verfügung.

Mit dem Parameter \texttt{-p} wird eine Menge von Parameterkombinationen ausgewählt. Zur Verfügung stehen dabei \textit{small\_set}, \textit{medium\_set} und \textit{large\_set}, außerdem können mittels \textit{random} zufällige Kombinationen erstellt werden, die Anzahl dieser zufälligen Kombinationen wird über den Parameter \texttt{--cn} festgelegt. % Die Kombination \textit{skew} zur Verfügung, die tailing erzeugende Parameter enthält.
Darüber hinaus können die Parameter \texttt{-n}, \texttt{-l}, \texttt{--mt} und \texttt{-a} mit der gleichen Funktion wie bei der Anwendung \texttt{simulation.py} benutzt werden, um Einstellungen an den Simulationen vorzunehmen. Dabei ist für den Ansatz \texttt{-a} die schrittweise Simulation als Standard gesetzt, da diese sich für das 2-Zustände Modell als weniger laufzeitintensiv erwiesen hat, siehe auch (Abschnitt \ref{chapter:imp_laufzeit_sim})

\todo{Beschreibung der Plots}

\paragraph{\texttt{3s\_simulate\_and\_plot.py}}
Analog zur \texttt{2s\_simulate\_and\_plot.py} können mit dieser Anwendungen Simulationen des 3-Zustände Modells gestartet und die Ergebnisse davon geplottet werden. Es gibt ebefalls die vier beschriebenen Möglichkeiten, Parameterkombinationen auszuwählen und die Einstellung an den Simulationen vorzunehmen. Allerdings ist hier der ereignisbasierte Ansatz für \texttt{-a} voreingestellt.
Es können auch für das 3-Zustände Modell Einzelpeaks mit oder ohne Quartile, sowie Spektren mit oder ohne Rauschen erstellt werden. Die anderen Plots der 2-Zustände Simulation stehen auf Grund der höheren Parameteranzahl nicht zur Verfügung.

\todo{plot\_zeitpunkt}


\subsection{Umsetzung der Algorithmen}
Die Algorithmen \ref{algo_by_Step} und \ref{algo_by_event} wurden jeweils für zwei und drei Zustände implementiert. 
 
Um insbesondere bei der Step-by-Step Implementierung eine schnelle Verarbeitung der Zustands- und Ortsarrays zu gewährleisten, wurden dafür \texttt{NumPy}-Arrays verwendet. Außerdem stellt \texttt{NumPy} \footnote{http://www.numpy.org/} Methoden zur Berechnung von Percentilen, geometrisch verteilte Zufallszahlen und Bestimmung der Position des größten Wertes einer Liste zur Verfügung, welche für die Implementierung genutzt wurden.
Für die graphische Ausgabe der Peaks und weitere geplottete Darstellungen im Bereich der Auswertung der Simulationen wurde \texttt{matplotlib} \footnote{http://matplotlib.org/} genutzt.

% Zur Simulation der beiden Modelle wurde Python 3.4 verwendet. Dabei existieren Abhängigkeiten von NumPy (Arrays zur schnellen Verarbeitung), SciPy (Berechnung von Peakdaten) und PyPlot (graphische Darstellung)

Die Datei \texttt{simulation.py} enthält alle Funktionen zur Simulation und Berechnung der Peakdaten. Wichtigster Bestandteil ist die abstrakte Klasse \texttt{Simulation} und die zwei Unterklassen \texttt{Simulation\_2s} und \texttt{Simulation\_3s}. Wie im vorherigen Kapitel gesehen, unterscheiden sich sowohl bei der Step-by-Step, als auch bei der By-Event Variante die Algorithmen nur durch die Umsetzung eines Berechnungsschrittes, sodass die Methoden zur Simulation eines Berechnungsschrittes bzw. Events in der Superklasse abstrakt sind und jeweils für das Modell passend in den Unterklassen implementiert wurden. In der Klasse \verb!Simulation_3s! sind zusätzlich auch die Vorberechnungen für die kumulierte Parametermatrix der Step-by-Step Simulation und die Wechselmatrix der By-Event Simulation zu finden.

Um eine Simulation zu starten, wird zunächst eine Instanz der Simulationsklasse erstellt:
\begin{verbatim}
new_Sim = (params, model, approach, length, number, maxtime, times)
\end{verbatim}                                                                                                  
Für das 2-Zustände Modell sind die Parameter \verb!params! ein Tupel aus $(p_\text{s}, p_\text{m})$. Für das allgemeine 3-Zustände Modell wird die Übergangsmatrix \ref{3s_Transit} als Liste von Listen \\ \verb![[pmm, pma, pml],[pam,paa,pal],[plm,pla,pll]]! übergeben. Wird als \verb!model! das Modell 3a ausgewählt, können die vier nötigen Parameter auch als Liste \verb![pmm,pml,paa,pll]! übergeben werden.
Zulässige Eingaben für \verb!model! sind \texttt{2s}, \texttt{3s} und \texttt{3a}, womit das entsprechende Modell ausgewählt wird. Über \verb!approach! kann zwischen \texttt{S} und \texttt{E} gewählt werden, wodurch der Simulationsansatz gewählt wird.
Mit \verb!length!, \verb!number! und \verb!maxtime! können die Rahmenparameter für die Simulation gesetzt werden, diese entsprechen $\ell$, $n$ und $t_{\text{max}}$ in den Algorithmen \ref{algo_by_Step} und \ref{algo_by_event}. Als Defaultwerte auch hier eine Länge von $1000$, sowie $1000$ Teilchen und eine maximale Zeit von $240$ Sekunden gesetzt.

Zusätzlich ist es möglich, eine bereits vorhandene Liste von Ankunftszeiten mit zu übergeben, aus der beispielsweise die Maße des Peaks berechnet werden sollen.

Mit \begin{verbatim}
new_Sim = ([0.5 0.0001 0.9993 0.99999], "3a", "S", number = 10000)
\end{verbatim} 
wird beispielsweise eine Simulationsinstanz mit den Parametern $pmm = 0,5$, $pml = 0,0001$, $paa = 0,9993$ und $pll = 0,99999$ für das Modell 3a erzeugt. Diese soll für $10.000$ Teilchen mit der Step-by-Step Simulation simuliert werden.

Anschließend wird mit \verb!newSim.simulate()! die Simulation gestartet. Anhand des gesetzten \verb!model! und \verb!approach! entscheidet sich, welche Funktionen zur Simulation aufgerufen werden. Die Peakdaten werden anschließend mittels \verb!newSim.calculate()! berechnet.

% %\subsection{Aufruf aus der Kommandozeile} 
% Um eine Simulation zu starten, kann das Programm auch mittels Kommandozeilenparameter gestartet werden. Der Aufruf
% \begin{verbatim}
% python3 simulation.py -a E -m 2s -l 1000 -n 10000 -mt 400  -p 0.999 0.5
% \end{verbatim}
% startet eine ereignisbasierte Simulation des 2-Zustände Modells bei einer Säulenlänge von $1000$, mit $10.000$ Teilchen und einer maximalen Wartezeit von $400$. Die Simulationsparameter sind $p_\text{s} = 0,999$ und $p_\text{m} = 0,5$. Anschließend wird das Ergebnis als einfaches Histogramm graphisch dargestellt.
% 
% Um jedoch mehr als eine Parameterkombination zu simulieren und auszuwerten, wird die Benutzung der Dateien \verb!2s_simulate_and_plot.py! sowie  \verb!3s_simulate_and_plot.py! empfohlen. Sie sind für das Starten der Simulationen und Plotten der Ergebnisse durch den Benutzer gedacht. Durch den Aufruf mit einigen Kommandozeilenparametern kann zunächst ein vordefinierte Menge an Parameterkombinationen zur Simulation ausgewählt und anschließend ausgewertet werden.
% 
% Mit dem Parameter \texttt{-p} wird eine Menge von Parameterkombinationen ausgewählt. Zur Verfügung stehen dabei für das 2-Zustände Modell und das 3-Zustände Modell 3a jeweils \textit{small\_set}, \textit{medium\_set} und \textit{large\_set}, außerdem können mittels \textit{random} zufällige Kombinationen erstellt werden, die Anzahl dieser zufälligen Kombinationen wird über den Parameter \texttt{-cn} festgelegt. Außerdem steht für das 2-Zustände Modell noch die Kombination \textit{skew} zur Verfügung, die tailing erzeugende Parameter enthält.
% 
% Der Parameter \texttt{-a} wählt den gewünschten Ansatz, also \texttt{-a=S} für die Step-by-Step Simulation und \texttt{-a=E} für die By-Event Simulation.
% 
% Mit den Parametern \texttt{-n} und \texttt{-l} können Anzahl der Teilchen und Länge der Säule eingegeben werden. Als Default-Werte dafür sind $1000$ Teilchen und eine Länge von $1000$ Schritten vorgesehen.
% 
% Um einen einzelnen Peak zu Plotten, kann mittels \texttt{-pp} die gewünschte Parameterkombination aus $p_\text{s}$ und $p_\text{m}$ eingegeben werden. Für die 2-Zustände Simulation würde beispielsweise der Aufruf \verb!python3 2s_simulate_and_plot.py -pp 0.999 0.5! eine Simulation mit den Parametern $p_\text{s} = 0,999$ und $p_\text{m} = 0,5$ erstellen, diese simulieren, falls sie noch nicht vorhanden ist und anschließend eine graphische Darstellung des Peaks ausgeben. 
% Für die 3-Zustände Simulation ist das Modell 3a als Voreinstellung gewählt, damit kann eine Parameterkombination aus $p_\text{mm}$, $p_\text{ml}$, $p_\text{aa}$ und $p_\text{ll}$ eingegeben werden. Um das gesamte 3-Zustände Modell auszunutzen, ist die Auswahl \texttt{-m=3s} nötig, und die Eingabe aller neun Parameter. 
% 
% Weitere Kommandozeilenparameter erlauben die Auswahl der gewünschten Plots. Dadurch werden die Plotfunktionen der Datei \texttt{plottings.py} aufgerufen. Dort sind mehrere verschiedene Möglichkeiten zur Auswertungen der Simulation enthalten, die unter Anderem auch verwendet wurden, um die Darstellungen in Kapitel \ref{chapter:eva} zu erstellen.  \todo{noch mehr hierzu?}
% 

\subsection{Optimierungen}
Sowohl bei der Umsetzung der Step-by-Step Methode als auch By-Event kann mit der Implementierung des 3-Zustände Modells auch das 2-Zustände Modell simuliert werden, indem nicht benötigte Übergangswahrscheinlichkeiten auf einen Wert von $0$ gesetzt werden. Die 2-Zustände Simulation ist aber vor allem bei der Step-by-Step Implementierung deutlich schneller, da nur auf boolschen Werten gearbeitet werden muss und deutlich weniger ungenutzte Information in den Zwischenschritten berechnet wird.

Im Laborexperiment wird nur in gewissen Intervallen die Ankunft von Teilchen detektiert, bei der MCC-IMS-Kopplung wird beispielsweise nur zwei Mal pro Sekunde eine Messung durchgeführt. Daher genügt es auch in der schrittweisen Simulation, wenn nicht nach jedem Simulationsschritt die Orte aller Teilchen getestet werden, um ein ausreichend exaktes Ergebnis zu erhalten.
Es können also zunächst viele Simulationsschritte durchgeführt werden, bevor getestet wird, ob Teilchen die Säulenlänge $\ell$ erreicht haben. Nach den oben angegebenen Einheiten können so zwischen jedem Test $50$ Simulationsschritte erfolgen, was $0,5$s entspricht. Dadurch entfallen viele Abfragen und es kann Simulationszeit eingespart werden. 

Da außerdem klar ist, dass Teilchen eine Säule der Länge $\ell$ frühestens nach $l$ Schritten überhaupt durchlaufen haben können, muss vor diesem Zeitpunkt auch kein Test auf Erreichen der Länge durchgeführt werden, wodurch weitere Zeit eingespart werden kann.

Diese Optimierungen wurden im Laufzeitvergleich im folgenden Abschnitt bereits berücksichtigt.

\subsection{Laufzeitvergleich von Step-by-Step und By-Event}
\label{chapter:imp_laufzeit_sim}
Die Laufzeit einer Simulation hängt stark von den gewählten Parametern ab, außerdem gibt es gravierende Unterschiede zwischen dem 2- und 3-Zustände Modell.

In Tabelle \ref{2s_laufzeit} ist eine Übersicht über die Laufzeiten der verschiedenen Simulationsarten gegeben. 
Jede Zeile enthält die Zeiten für die gegebenen Parameter, jede Spalte entspricht einer Kombination aus Simulationsart und Teilchenanzahl $n$.

Die Zeiten wurden auf einem Rechner mit Intel® Core™ i7-4500U Processor 
unter jeweils gleichen Bedingungen gemessen und sind in Sekunden angegeben. \todo{Hinweise, was für nen PC ich habe}
Mit einem $*$ gekennzeichnete Zeiten deuten an, dass die Simulationen nach Erreichen der maximalen Anzahl Simulationsschritte beendet wurden, also keinen vollständigen Peak innerhalb dieses Zeitraumes liefern.


\begin{table}[h]
\centering
\caption[Laufzeitvergleich für die 2-Zustände Simulation]{Laufzeitvergleich für die 2-Zustände Simulation mit den Parametern $ps$ und $pm$ für $n$ Teilchen, Zeitangaben in Sekunden. Mit * gekennzeichnete Zeiten zeigen unvollständigen Peak innerhalb von $240$ Sekunden an.}
\label{2s_laufzeit}
\begin{tabular}{|l|l||l|l|l|l|} \hline
$p_\text{s}$ & $p_\text{m}$  & Step-by-Step & By-Event & Step-by-Step & By-Event \\ 
 &   & $n=1000$ &$n=1000$ &$n=10.000$ &$n=10.000$  \\ \hline \hline
$0,997  $ & $ 0,001 $ & $ 8,4  $ & $ 20,9  $ & $ 47,4  $ & $98,2  $\\ \hline
$0,997  $ & $ 0,3  $ & $ 6,1  $ & $ 15,4  $ & $ 33,7  $ & $69,3  $\\ \hline
$0,997  $ & $ 0,6  $ & $ 3,6  $ & $ 8,9   $  & $ 19,4 $ & $40,1  $\\ \hline
$0,997  $ & $ 0,95 $ & $ 0,6  $ & $ 1,3   $  & $ 2,6  $ & $5,4   $\\ \hline
$0,999  $ & $ 0,001 $ & $ 25,5 $ & $ 40,2  $ & $ 142,7 $ & $124,5 $\\ \hline
$0,999  $ & $ 0,3  $ & $ 18,6 $ & $ 27,8  $ & $ 100,4 $ & $88    $\\ \hline
$0,999  $ & $ 0,6  $ & $ 11,0 $ & $ 16,1  $ & $ 57,8  $ & $51    $\\ \hline
$0,999  $ & $ 0,95 $ & $ 1,7  $ & $ 2,2   $ & $ 7,6   $ & $7,1   $\\ \hline
$0,9993 $ & $ 0,001 $ & $ 37,6 $ & $ 47,6  $ & $ 204,1 $ & $140,4 $\\ \hline
$0,9993 $ & $ 0,3  $ & $ 26,6 $ & $ 32,7  $ & $ 143,4 $ & $99,3  $\\ \hline
$0,9993 $ & $ 0,6  $ & $ 15,3 $ & $ 19,6  $ & $ 82,6  $ & $57,6  $\\ \hline
$0,9993 $ & $ 0,95 $ & $ 2,3  $ & $ 2,5   $ & $ 10,8  $ & $8,1   $\\ \hline
$0,9996 $ & $ 0,001 $ & $ 59,9*$ & $ 54,3* $ & $341,2* $ & $167,8*$\\ \hline
$0,9996 $ & $ 0,3  $ & $ 46,2 $ & $ 39,5  $ & $ 252,6 $ & $125,4 $\\ \hline
$0,9996 $ & $ 0,6  $ & $ 26,7 $ & $ 22,4  $ & $ 150,2 $ & $72,8  $\\ \hline
$0,9996 $ & $ 0,95 $ & $ 4,1  $ & $ 3,0   $ & $ 18,8  $ & $10,2  $\\ \hline
\end{tabular}
\end{table}

Wie zu erwarten war, steigt die Laufzeit an, je größer $p_\text{s}$ und je kleiner $p_\text{m}$ ist. Das liegt offensichtlich an der Abbruchbedingung des Algorithmus, der terminiert, wenn alle Teilchen über die gesamte Strecke von $\ell$ Schritten simuliert wurden. Simulationsparameter mit kleinem $p_\text{s}$ oder großem $p_\text{m}$ sorgen für weniger Verweilen der Teilchen im stationären Zustand und damit eine schnelle Passage der Strecke, wodurch die Simulationsdauer kürzer wird. 

Bei der Simulation den 2-Zustände Modells ist die Step-by-Step Variante für die meisten Parameterkombinationen deutlich schneller, als die By-Event Implementierung. Der große Vorteil von Step-by-Step liegt hier in der Verwendung von booleschen Werten und Nutzung von NumPy-Arrays, auf welchen die Ausführung logischer Operationen sehr schnell erfolgen kann. Diese Zeiten der Step-by-Step Implementierung würden sich allerdings fast verdoppeln, wenn tatsächlich nach jedem Simulationsschritt eine Abfrage auf Erreichen der Säulenlänge und entsprechende Bearbeitung der fertigen Teilchen erfolgen würde und nicht erst nach den oben erwähnten $50$ Schritten.

Mit größer werdendem $p_\text{m}$ verringert sich der Unterschied zwischen den beiden Simulationsarten, ab einem sehr großen Wert für $p_{\text{m}}$, ab etwa $0,99$ ist die By-Event Variante geringfügig schneller. Das liegt daran, dass in diesen Fällen besonders selten Ereignisse erzeugt werden müssen und sich die Teilchen in großen Sprüngen forbewegen können. 

Anders sieht die Situation bei der Simulation des 3-Zustände Modells 3a aus. Tabelle \ref{3s_laufzeit} bietet eine Übersicht über die Laufzeiten mit verschiedenen Parametern.
In der Spalte */** ist gekennzeichnet, ob die Parameter einen Peak innerhalb der Retentionszeit von $240$ Sekunden erzeugen. Bei mit einem * markierten Zeilen erreichen nur einige Teilchen ($<20\%$) innerhalb der Zeit das Säulenende. Zwei ** stehen für eine Simulation, in der fast alle ($> 95\%$) der Teilchen das Ziel erreichen.

\begin{table}[h]
\centering 
\caption[Laufzeitvergleich für die 3-Zustände Simulation]{Laufzeitvergleich für die 3-Zustände Simulatio nmit den Parametern und $pmm$, $pml$, $paa$ und $pll$ für $n$ Teilchen, Zeitangaben in Sekunden. Grau hinterlegte Kombinationen zeigen einen unvollständigen Peak innerhalb von $240$ Sekunden an, in der Spalte \% ist für diese der Prozentsatz angekommener Teilchen vermerkt.}
\label{3s_laufzeit}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
$p_\text{mm}$ & $p_\text{ml}$ & $p_\text{aa}$ & $p_\text{ll}$ & \%& S, $1000$ & E, $1000$ & S, $10.000$ & E, $10.000$ \\ \hline \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,99995$  && $26,2   $ & $23,9  $ & $123,7 $ & $196,1 $  \\ \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,999995$ && $47,4   $ & $24,4  $ & $150   $ & $198,9 $  \\ \hline
\cellcolor{gray!25}$ 0,01 $ & \cellcolor{gray!25}$0,00005$ &\cellcolor{gray!25} $0,9996$ &\cellcolor{gray!25} $0,99995$  &$18$& $170,8 $ & $35,9  $ & $870   $ & $219,4 $  \\ \hline
\cellcolor{gray!25}$ 0,01 $ & \cellcolor{gray!25}$0,00005$ &\cellcolor{gray!25} $0,9996$ & \cellcolor{gray!25}$0,999995$ &$18$& $169,7 $ & $35,4  $ & $869   $ & $220,5 $  \\ \hline
$ 0,01 $ & $0,003 $  & $0,997$  & $0,99995$  && $36,2   $ & $25,2  $ & $150,6 $ & $199,4 $  \\ \hline
\cellcolor{gray!25}$ 0,01 $ & \cellcolor{gray!25}$0,003 $  & \cellcolor{gray!25}$0,997$  & \cellcolor{gray!25}$0,999995$ &$99$& $118,8$ & $31,5  $ & $390,7 $ & $218,3 $  \\ \hline
\cellcolor{gray!25}$ 0,01 $ & \cellcolor{gray!25}$0,003 $  & \cellcolor{gray!25}$0,9996$ & \cellcolor{gray!25}$0,99995$  &$8$& $170   $ & $34,8  $ & $870   $ & $217,5 $  \\ \hline
\cellcolor{gray!25}$ 0,01 $ & \cellcolor{gray!25}$0,003 $  & \cellcolor{gray!25}$0,9996$ & \cellcolor{gray!25}$0,999995$ &$2$& $170   $ & $29,9  $ & $871   $ & $188,5 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,99995$  && $5      $ & $2,6 $   & $15,5  $ & $20,7 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,999995$ && $28,4   $ & $2,7 $   & $44,3  $ & $21,4 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,99995$  && $22,5   $ & $3,9 $   & $98    $ & $24,3 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,999995$ && $49,9   $ & $4 $     & $126,1 $ & $24,9 $  \\ \hline
$ 0,9  $ & $0,003 $  & $0,997$  & $0,99995$  && $16,9   $ & $3,3 $   & $43    $ & $22,6 $  \\ \hline
\cellcolor{gray!25}$ 0,9  $ & \cellcolor{gray!25}$0,003 $  & \cellcolor{gray!25}$0,997$  & \cellcolor{gray!25}$0,999995$ &$99$& $108,3$ & $4,3   $ & $294,2 $ & $30,6 $  \\ \hline
$ 0,9  $ & $0,003 $  & $0,9996$ & $0,99995$  && $30,1   $ & $4,0 $   & $120 $   & $25,3 $  \\ \hline
\cellcolor{gray!25}$ 0,9  $ & \cellcolor{gray!25}$0,003 $  & \cellcolor{gray!25}$0,9996$ & \cellcolor{gray!25}$0,999995$ &$99$& $115,6$ & $4,7   $ & $370,6 $ & $32,4$  \\ \hline
\end{tabular}
\end{table}
Auch hier ist für beide Simulationsarten zu erkennen, dass bei größerem $p_\text{mm}$ oder kleineren Werten für die anderen Parametern deutlich geringere Laufzeiten erreicht werden.

Jedoch müssen bei der Step-by-Step Implementierung sehr viele Einträge für die Hilfsarrays erzeugt werden, die für die Berechnung der neuen Arrays nicht benötigt werden. Durch diese überflüssigen Berechnungen verliert die Step-by-Step Implementierung ihren Vorteil gegen über der By-Event Variante, sodass diese schneller wird. Besonders bei denjenigen Simulationen, die einen sehr späten Peak erzeugen oder gar keinen vollständigen Peak innerhalb der $240$ Sekunden erzeugen, wird der Vorteil der By-Event Simulation deutlicher. In diesen Fällen finden meist seltener Wechsel von der stationären in die mobile Phase statt. Bei der Step-by-Step Variante wird dennoch jeder Schritt simuliert, ohne dass sich die Teilchen bewegen. By-Event lässt diese Schritte einfach aus, wodurch deutlich Simulationszeit gespart wird. 
%Dies wird noch deutlicher, je größer $p_{\text{mm}}$ wird.

%Bei Parametern nah an $1$ lohnt meist die Nutzung der By-Event Implementierung, da dann nur seltener Ereignisse erzeugt werden und viele Schritte in denen nichts passiert, also kein Zustandswechsel stattfindet, übersprungen werden können.
%Bei sehr vielen Teilchen lohnt sich eher die Step-by-Step Variante, da die Teilchen, die in NumPy-Arrays als boolesche Werte vorliegen, sehr viel schneller verarbeitet werden können, als die Listen, die bei der Event -Variante verwendet werden. Eine weitere Parallelisierung scheint hier aber nicht zu lohnen
%Zumindest bei Parametern extrem nah bei 1 kann sich die Laufzeit der By-Event stark vergrößern, wenn die Säule zu kurz ist, da die Teilchen ``viel zu weit über das Ziel hinausschiessen'', aber das erst später festgestellt wird, wenn das Teilchen wieder betrachtet wird und schon entsprechend viele Zeitschritte vergangen sind. 

% Generelles: Welche Sprachen, warum (?)
% Die Simulation in Python, beide Varianten (Also by-event und step-by-step) 
% -> Algorithmen?

\section{Simulation des PAA}
TODO

\subsection{Nutzung von MoSDi}
Es existiert bereits eine Implementierung für PAA. Diese wurde innerhalb der Software \texttt{MoSDi} \footnote{https://bitbucket.org/tobiasmarschall/mosdi} realisiert und ist in \cite{Marschall2011} beschrieben. Um eine Simulation eines PAA mit \texttt{MoSDi} zu starten, muss für die darin enthaltene abstrake Klasse \texttt{PAA} eine Unterklasse geschrieben werden, welche die Zustände, Werte, Operationen und Transitionswahrscheinlichkeiten für den konkreten PAA enthält. In der mitglieferten CD finden sich für beide Modelle jeweils eine solche Unterklasse \texttt{myPAA\_2s} und \texttt{myPAA\_3s}. 
Zum starten muss in der Kommandozeile nacheinander die Befehle
\begin{verbatim}
javac -classpath mosdi-1.3.jar myPAA_2s.java
java -classpath .:mosdi-1.3.jar myPAA_2s 
\end{verbatim}
eingegeben werden. Dabei ist darauf zu achten, dass sich \texttt{mosdi.jar} im gleichen Verzeichnis wie \texttt{myPAA\_2s.java} befindet. 

\subsection{PAA-Sim}
Wie im Kapitel \ref{chapter:meth} erwähnt, werden für die Modelle der Multikapillarsäule jedoch nicht alle Funktionalitäten benötigt, sodass zusätzlich noch eine eigene Implementierung erstellt wurde. Diese wurde in Julia \footnote{julialang.org} implementiert und sind in den Programmen \verb!2s_PAA.jl! und \verb!3s_PAA.jl! zu finden.


\subsection{Verwertung der Verteilungen}
Sowohl bei der Simulation des PAA mittels \texttt{MoSDi} als auch mittels \texttt{PAA-Sim} wird das Ergebnis, die Ankunftswahrscheinlichkeiten für jeden Zeitpunkt, als einfache Liste der Wahrscheinlichkeiten in einer \texttt{.csv}-Datei gespeichert. Zur Weiterverarbeitung und zum Auswerten der Ergebnisse gibt es die Module \verb!process_simulations.py! und \verb!plottings_PAA.py!, welche wiederum in Python 3.4 implementiert wurden.

\paragraph{process\_simulations.py}

Dies entspricht bei $240$ Sekunden und $10.000$ Simulationsschritten pro Sekunde immerhin Einzelwahrscheinlichkeiten für $2.400.000$ Zeitpunkte. Um daher die resultierende Datenmenge zu reduzieren, werden die Einzelwahrscheinlichkeiten mit comp\_factor zusammengefasst.

Berechnet Peakdaten

\paragraph{plottings\_PAA.py}
Für das Plotten der Ergebnisse der PAA Simulationen existieren ähnliche Möglichkeiten, wie bei der Teilchensimulation.


\subsection{Vergleich}

 Bei den 2s gibt es für alle PAA mit cut den break, außer der nicht fertig gewordenen natürlich und der 09996 03 - er sim auch
\begin{table}[h]
\centering
\caption[Laufzeitvergleich für die 2-Zustände Simulation]{Laufzeitvergleich für die 2-Zustände Simulation, Zeitangaben in Sekunden}
\label{2s_laufzeit_paa}
\begin{tabular}{|l|l||l|l|l|l|} \hline
$p_\text{s}$ & $p_\text{m}$  & PAA & PAA & MoSDi \\  \hline \hline
$0,997  $ & $ 0,001$ & $2,6  $ & $ $ & $ 195$ \\ \hline
$0,997  $ & $ 0,3  $ & $2,8  $ & $ $ & $ 197 $ \\ \hline
$0,997  $ & $ 0,6  $ & $2,1  $ & $ $ & $ 205 $ \\ \hline
$0,997  $ & $ 0,95 $ & $0,7  $ & $ $ & $ 220$ \\ \hline
$0,999  $ & $ 0,001$ & $8,0  $ & $ $ & $ 79$ \\ \hline
$0,999  $ & $ 0,3  $ & $7,2  $ & $ $ & $ 93$ \\ \hline
$0,999  $ & $ 0,6  $ & $6,1  $ & $ $ & $ 115$ \\ \hline
$0,999  $ & $ 0,95 $ & $2,3  $ & $ $ & $ 161$ \\ \hline
$0,9993 $ & $ 0,001$ & $11,3 $ & $ $ & $ 43$ \\ \hline
$0,9993 $ & $ 0,3  $ & $10,5 $ & $ $ & $ 47$ \\ \hline
$0,9993 $ & $ 0,6  $ & $8,4  $ & $ $ & $ 60$ \\ \hline
$0,9993 $ & $ 0,95 $ & $3,2  $ & $ $ & $ 126$ \\ \hline
\cellcolor{gray!25}$0,9996 $ &\cellcolor{gray!25} $ 0,001$ & $16,8 $ & $ $ & $ 20$ \\ \hline
$0,9996 $ & $ 0,3  $ & $18,2 $ & $ $ & $ 20$ \\ \hline
$0,9996 $ & $ 0,6  $ & $15,0 $ & $ $ & $ 20$ \\ \hline
$0,9996 $ & $ 0,95 $ & $5,6  $ & $ $ & $ 32$ \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering 
\caption{Laufzeitvergleich für die 3-Zustände Simulation, PAA}
\label{3s_laufzeit_paa}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
$p_\text{mm}$ & $p_\text{ml}$ & $p_\text{aa}$ & $p_\text{ll}$ &*/**& PAA & PAA & MoSDi \\ \hline \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,99995$  &&  $40, b $ & $180  $ & $26 $  \\ \hline
$ 0,01 $ & $0,00005$ & $0,997$  & $0,999995$ &&  $132  $ & $133  $ & $27 $  \\ \hline
$ 0,01 $ & $0,00005$ & $0,9996$ & $0,99995$  &18,2& $65 $ & $154  $ & $30 $  \\ \hline
$ 0,01 $ & $0,00005$ & $0,9996$ & $0,999995$ &17,7& $96 $ & $142  $ & $ 32 $  \\ \hline
$ 0,01 $ & $0,003 $  & $0,997$  & $0,99995$  &&  $58, b  $ & $157  $ & $27 $  \\ \hline
$ 0,01 $ & $0,003 $  & $0,997$  & $0,999995$ &98,8&$131  $ & $134  $ & $ 28 $  \\ \hline
$ 0,01 $ & $0,003 $  & $0,9996$ & $0,99995$  &8,2& $73  $ & $148  $ & $ 30  $  \\ \hline
$ 0,01 $ & $0,003 $  & $0,9996$ & $0,999995$ &1,6& $94  $ & $142  $ & $32 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,99995$  &&  $35, b $ & $184 $   & $26 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,997$  & $0,999995$ &&  $138   $ & $129 $   & $27 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,99995$  &&  $44, b $ & $177 $   & $27 $  \\ \hline
$ 0,9  $ & $0,00005$ & $0,9996$ & $0,999995$ &&  $143   $ & $127 $  & $26 $  \\ \hline
$ 0,9  $ & $0,003 $  & $0,997$  & $0,99995$  &&  $55, b $ & $162 $   & $ 27$  \\ \hline
$ 0,9  $ & $0,003 $  & $0,997$  & $0,999995$ &99,5&$140  $ & $131   $ & $27 $  \\ \hline
$ 0,9  $ & $0,003 $  & $0,9996$ & $0,99995$  &&  $58   $ & $157 $   & $28 $  \\ \hline
$ 0,9  $ & $0,003 $  & $0,9996$ & $0,999995$ &99& $129 $ & $130 $ & $26 $  \\ \hline
\end{tabular}
\end{table}


Laufzeitvergleich


TODO TODO TODO


