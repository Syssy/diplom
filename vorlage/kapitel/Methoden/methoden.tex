\chapter{Methoden} 
\label{chapter:meth}

In diesem Kapitel werden für die verschiedenen Modelle Möglichkeiten beschrieben, diese zu simulieren. Offensichtlich ist es möglich, tatsächlich jeden einzelnen Zeitschritt für alle Teilchen zu betrachten. Wenn Zustandswechsel jedoch nicht sehr häufig vorkommen, kann es viel Zeit einsparen, nur zu relevanten Zeitpunkten, also für jeden Zustandswechsel, zu simulieren und dabei den Zeitpunkt des nächsten Wechsels zu notieren.

Im zweiten Abschitt des Kapitels wird beschieben, wie der PAA umgesetzt werden kann. Dabei liegt der Fokus auf einer eingeschränkten Variante des PAA, bei dem einige nicht benötigte Funktionalitäten, wie beispielsweise je Zustand verschiedene Operationen oder mehrere mögliche Emissionen, nicht berücksichtigt werden.


\section{Simulation}
Zunächst betrachten wir das in \ref{chapter:mod:2p} vorgestellte Modell mit nur zwei Zuständen und zwei Parametern, anschließend auch die in \ref{chapter:mod:3s} beschriebene Erweiterung auf 3 Zustände und damit bis zu 6 Parameter.

Die Ankunftszeiten der simulierten Teilchen können dann als Peak aufgefasst und dargestellt werden. Außerdem werden daraus die resultierenden Peakdaten berechnet.
%Nach erfolgter Simulation können aus den Ankunftszeiten der Teilchen die Peakdaten der resultierenden Peaks berechnet werden.

\todo{Berechnung der Peakdaten, wohin}

\subsection{Simulation des 2-Parameter Modells}
Für das 2-Parameter Modell wurden zwei verschiedene Möglichkeiten der Simulation entworfen. Die erste, ``Step-by-Step'', simuliert schrittweise alle Zeitpunkte eines Säulendurchlaufs. Die zweite, ``By-Event'' verwaltet eine Liste relevanter Zeitpunkte, an denen Ereignisse - im konkreten Fall: Zustandswechsel - statt finden.

\subsubsection{Step-by-Step}
\begin{algorithm}
\caption{Ablauf der Step-by-Step Simulation}
\label{algo_by_Step}
\begin{algorithmic}
\REQUIRE Zustandsliste $s= [s_1 = 1, \ldots, s_n=1]$, Ortsliste $o=[o_1=0, \ldots , o_n=0]$, Zeit $t=0$, Maximalzeit $t_{max}$
\ENSURE Ankuftszeiten $r$
\WHILE{$t < t_{max}$ \AND $len(s) > 0$}
\FORALL {$p$}
\STATE Simuliere $p$
\IF {$o_p >l$}
\STATE $r \leftarrow t$
\STATE Lösche $s_p$ und $o_p$
\ENDIF
\ENDFOR
\STATE $t +=1$
\ENDWHILE
\RETURN $r$
\end{algorithmic}
\end{algorithm}

\todo{Hinweis auf Parallelisierbarkeit und andere Zeitverbesserungen hier oder in Implementierung}

%TODO: Zustand $s \in \{0, 1\}$ Ort $o \in \{0, \ldots, l\}$ wobei $l$ die Länge der Säule ist. -> in text einbauen


Der Ablauf einer Simulation ist in Algorithmus \ref{algo_by_Step} gegeben.

Für jedes Teilchen $p$ muss jeweils der aktuelle Zustand $s$ und Ort $o$ festgehalten werden, außerdem muss der aktuelle Zeitpunkt $t$ vermerkt werden. Da nur zwei Zustände existieren, bietet es sich an, dafür ein Array mit booleschen Werten zu verwenden. $0$ steht dabei für stationär und $1$ für mobil. Die Identifikation der Teilchen geschieht dabei über ihre Postition im Array.
\todo{Array oder Vektor, bzw ohne Parallelisierbarkeit, da ja eigentlich nicht nötig?}
%Für jedes Teilchen wird in einem zweiten Array an gleicher Position sein aktueller Ort gespeichert. 

Die Teilchen wechseln in jedem Schritt mit einer bestimmten Wahrscheinlichkeit den Zustand. Diese sei $pm$ für das Verweilen in der mobilen Phase, $ps$ für das Verweilen in der stationären Phase und $1-pm$ bzw. $1-ps$ für die beiden Möglichkeiten des Phasenwechsels. Daher muss pro Schritt und Teilchen eine Zufallszahl gezogen werden, anhand derer sich entscheidet, wie es sich verhält. Außerdem muss in jedem Schritt der Ort für jedes mobile Teilchen um eins erhöht werden.

Zum Ablauf der Simulation wurde entschieden, dass zunächst die Entscheidung über die Phase gefällt wird und sich anschließend die Teilchen gemäß ihres neuen Zustandes bewegen. Außerdem starten alle Teilchen ganz zu Beginn in der mobilen Phase, da sie nur so in das System eintreten können.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\fseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]


\begin{scope}[start chain =1 going right, node distance =0.0mm]
	\node [on chain =1, feld, draw=none] {Phasen};
	\node [on chain=1, feld, fill=blue!30!white] (p1) {0};
	\node [on chain=1, feld] (p3) {0};
	\node [on chain=1, feld, fill=green!30!white] (p4) {1};
	\node [on chain=1, feld] (p5) {1};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (p6) {1};
	\node [on chain=1, feld] (p7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (p8) {0};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -1cm)}]
	\node [on chain =1, feld, draw=none] {Orte};
	\node [on chain=1, feld] (o1) {0};
	\node [on chain=1, feld] (o3) {4};
	\node [on chain=1, feld] (o4) {4};
	\node [on chain=1, feld] (o5) {1};
	\node [on chain=1, feld] (o6) {6};
	\node [on chain=1, feld] (o7) {6};
	\node [on chain=1, feld] (o8) {3};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -2.5cm)}]
	\node [on chain =1, feld, draw=none] {ZV};
	\node [on chain=1, feld] (z1) {$0,9$};
	\node [on chain=1, feld] (z3) {$0,6$};
	\node [on chain=1, feld] (z4) {$0,2$};
	\node [on chain=1, feld] (z5) {$0,9$};
	\node [on chain=1, feld] (z6) {$0,7$};
	\node [on chain=1, feld] (z7) {$0,2$};
	\node [on chain=1, feld] (z8) {$0,3$};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -3.5cm)}]
	\node [on chain =1, feld, draw=none] {$p_s = 0,8$};
	\node [on chain=1, feld, fill=blue!30!white] (ps1) {0};
	\node [on chain=1, feld] (ps3) {1};
	\node [on chain=1, feld] (ps4) {1};
	\node [on chain=1, feld] (ps5) {0};
	\node [on chain=1, feld] (ps6) {1};
	\node [on chain=1, feld] (ps7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (ps8) {1};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -4.5cm)}]
	\node [on chain =1, feld, draw=none] {$p_m = 0,5$};
	\node [on chain=1, feld] (pm1) {0};
	\node [on chain=1, feld] (pm3) {0};
	\node [on chain=1, feld, fill=green!30!white] (pm4) {1};
	\node [on chain=1, feld] (pm5) {0};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (pm6) {0};
	\node [on chain=1, feld] (pm7) {1};
	\node [on chain=1, feld] (pm8) {1};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm, shift={(0cm, -6cm)}]
	\node [on chain =1, feld, draw=none] {Phasen};
	\node [on chain=1, feld, fill=blue!30!white] (np1) {1};
	\node [on chain=1, feld] (np3) {0};
	\node [on chain=1, feld, fill=green!30!white] (np4) {1};
	\node [on chain=1, feld] (np5) {0};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (np6) {0};
	\node [on chain=1, feld] (np7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (np8) {0};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -7cm)}]
	\node [on chain =1, feld, draw=none] {Orte};
	\node [on chain=1, feld] (no1) {1};
	\node [on chain=1, feld] (no3) {4};
	\node [on chain=1, feld] (no4) {5};
	\node [on chain=1, feld] (no5) {1};
	\node [on chain=1, feld] (no6) {6};
	\node [on chain=1, feld] (no7) {7};
	\node [on chain=1, feld] (no8) {3};
\end{scope}

\end{tikzpicture}
\caption{Prinzip der schrittweisen Simulation bei zwei Parametern}
\label{2p_by_step}
\end{figure}

In Abbildung \ref{2p_by_step} ist eine schematische Darstellung eines Simulationsschritts zu finden. Hier werden die Teilchen alle parallel bearbeitet 
\todo{müsste hier nicht schon ein verweis auf numpy hin?}
Um eine Abfrage des aktuellen Zustand zu sparen, wird einfach für beide Möglichkeiten berechnet. \todo{benennung der pspmvektoren}
Dadurch können alle Zustandswechsel ebenfalls parallel über die Formel: $(p \land pm) \lor (\lnot p \land \lnot ps)$ berechnet werden.
Für die neuen Orte kann einfach der neue Zustandsvektor auf den alten Ortsvektor addiert werden.

Nach jedem solchen Simulationsschritt wird getestet, ob Teilchen bereits den Wert von $l$ erreicht und damit die ganze Säule durchlaufen haben. Die entsprechende Anzahl dafür benötigter Schritte entspricht der Ankunftszeit der Teilchen und wird festgehalten, sodass als Ergebnis am Ende der Simulation eine Liste von Ankunftszeiten aller Teilchen entsteht. Teilchen, die angekommen sind, werden aus beiden Vektoren gelöscht.

Die Simulation ist beendet, wenn alle Teilchen das Säulenende erreicht haben, also die Vektoren eine Länge von $0$ haben. 
Als alternative Abbruchbedingung kann eine maximale Anzahl von Simulationsschritten gewählt werden, nach deren Ablauf die Simulation beendet ist, wenn nur Peaks von Interesse sind, die vor diesem Zeitpunkt im Chromatogramm erscheinen.

\todo{Wo stehen Zeiteinheiten festgelegt -> ImAnplementierung}


\subsubsection{By-Event}

\todo{Beide Algo: Invalidflag?}
\begin{algorithm}
\caption{Ablauf der by-Event Simulation}
\label{algo_by_event}
\begin{algorithmic}
\REQUIRE Eventliste $e= [e_0 = [(s_0, o_0), \ldots, (s_n, o_n)]]$ mit $s_p = 1, o_p = 0$, $\forall p$ , Zeit $t=0$, Maximalzeit $t_{max}$
\ENSURE Ankuftszeiten $r$
\WHILE{$t<t_{max}$ \AND Länge $e> 0$}
%\STATE Teilchenliste $= e[t]$
\FORALL {$(s_p, o_p)$ in $e[t]$}
\IF {$o_p > l$}
\STATE Berechne $t_a(p)$ 
\STATE $r \leftarrow t_a(p)$
\STATE Lösche $(s_p, o_p)$
\ELSE
\STATE Simuliere $(s_p, o_p)$
\STATE Aktualisiere $e$
\ENDIF
\ENDFOR
\STATE $t+=1$
\ENDWHILE
\RETURN $r$
\end{algorithmic}
\end{algorithm}

Der Ablauf der ereignisbasierten Simulation ist in \ref{algo_by_event} angegeben.

Dabei muss für jeden Zeitpunkt $t$ verwaltet werden, welche Teilchen zu diesem Zeitpunkt ihren Zustand wechseln. Jedes Teilchen besteht dabei aus seinem Ort und seinem Zustand. 
Zunächst starten alle Teilchen wie bei der schrittweisen Simulation bei Zeitpunkt $1$, Ort $0$ und mobil.
Ein Simulationsschritt behandelt dann alle Teilchen eines Zeitpunktes. Ein solches Event beinhaltet den Wechsel des Zustands, die Bestimmung des Zeitpunkts des nächsten Zustandswechsels sowie bei mobilen Teilchen eine Änderung des Ortes. Anschließend wird das Teilchen der Zeitpunkteliste seines nächsten Aktionszeitpunktes hinzugefügt. Sind alle Teilchen abgearbeitet, wird der Zeitpunkt gelöscht und der nächste Zeitpunkt, an dem etwas passieren soll, bearbeitet.

\begin{figure}
\begin{subfigure}[t]{\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]

\begin{scope}[start chain =1 going right, node distance =-0.3mm]
	\node [on chain =1, feld, draw=none,minimum width=2cm] {Events $e$};
	\node [on chain=1, feld,minimum width=2cm] (p2) {$e_2$};
	\node [on chain=1, feld,minimum width=2cm] (p3) {$e_3$};
	\node [on chain=1, feld,minimum width=2cm] (p5) {$e_5$};
	\node [on chain=1, feld,minimum width=2cm] (p7) {$e_7$};
	\node [on chain=1, feld,minimum width=2cm] (p12) {$e_{12}$};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(2cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=green!50!white] (1x1) {($s_1, o_1$)};
	\node[on chain = 1, feld, fill=blue!40!white] (1x2) {($s_4, o_4$)};
	\node[on chain = 1, feld, fill=orange!50!white] (1x3) {($s_7, o_7$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(4cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (2x1) {($s_0, o_0$)};
	\node[on chain = 1, feld] (2x2) {($s_8, o_8$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(6cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (3x1) {($s_{10}, o_{10}$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(8cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (4x1) {($s_2, o_2$)};
	\node[on chain = 1, feld] (4x2) {($s_3, o_3$)};
	\node[on chain = 1, feld] (4x3) {($s_9, o_9$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(10cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (5x1) {($s_5, o_5$)};
\end{scope}

\path [line width=1.4pt, line cap=rect, draw](p2) edge (1x1) ;
\path [line width=1.4pt, line cap=rect, draw](1x1) edge (1x2) ;
\path [line width=1.4pt, line cap=rect, draw](1x2) edge (1x3) ;

\path [line width=1.4pt, line cap=rect, draw](p3) edge (2x1) ;
\path [line width=1.4pt, line cap=rect, draw](2x1) edge (2x2) ;

\path [line width=1.4pt, line cap=rect, draw](p5) edge (3x1) ;

\path [line width=1.4pt, line cap=rect, draw](p7) edge (4x1) ;
\path [line width=1.4pt, line cap=rect, draw](4x1) edge (4x2) ;
\path [line width=1.4pt, line cap=rect, draw](4x2) edge (4x3) ;

\path [line width=1.4pt, line cap=rect, draw](p12) edge (5x1) ;

\end{tikzpicture}
\label{2p_by_event_a}
\caption{Vor der Simulation des Events $e_1$}
\vspace*{5mm}
\end{subfigure}
\begin{subfigure}[b]{\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]

\begin{scope}[start chain =1 going right, node distance =-0.3mm]
	\node [on chain =1, feld, draw=none,minimum width=2cm] {Events $e$};
	\node [on chain=1, feld,minimum width=2cm] (p2) {$e_2$};
	\node [on chain=1, feld,minimum width=2cm] (p5) {$e_5$};
	\node [on chain=1, feld,minimum width=2cm] (p7) {$e_7$};
	\node [on chain=1, feld,minimum width=2cm] (p9) {$e_9$};
	\node [on chain=1, feld,minimum width=2cm] (p12) {$e_{12}$};
	\node [on chain=1, feld,minimum width=2cm] (p16) {$e_{16}$};
\end{scope}


\begin{scope}[start chain = 1 going below,shift={(2cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (2x1) {($s_0, o_0$)};
	\node[on chain = 1, feld] (2x2) {($s_8, o_8$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(4cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (5x1) {($s_{10}, o_{10}$)};
	\node[on chain = 1, feld, fill=green!50!white] (5x2) {($s_1, o_1$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(6cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (7x1) {($s_2, o_2$)};
	\node[on chain = 1, feld] (7x2) {($s_3, o_3$)};
	\node[on chain = 1, feld] (7x3) {($s_9, o_9$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(8cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=orange!50!white] (9x1) {($s_7, o_7$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(10cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (12x1) {($s_5, o_5$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(12cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=blue!40!white] (16x1) {($s_4, o_4$)};
\end{scope}

%\path [line width=1.4pt, line cap=rect, draw](1x2) edge (1x3) ;

\path [line width=1.4pt, line cap=rect, draw](p2) edge (2x1) ;
\path [line width=1.4pt, line cap=rect, draw](2x1) edge (2x2) ;

\path [line width=1.4pt, line cap=rect, draw](p5) edge (5x1) ;
\path [line width=1.4pt, line cap=rect, draw](5x1) edge (5x2) ;

\path [line width=1.4pt, line cap=rect, draw](p7) edge (7x1) ;
\path [line width=1.4pt, line cap=rect, draw](7x1) edge (7x2) ;
\path [line width=1.4pt, line cap=rect, draw](7x2) edge (7x3) ;

\path [line width=1.4pt, line cap=rect, draw](p9) edge (9x1) ;

\path [line width=1.4pt, line cap=rect, draw](p12) edge (12x1) ;

\path [line width=1.4pt, line cap=rect, draw](p16) edge (16x1) ;

\end{tikzpicture}

\label{2p_by_event_b}
\caption{Nach der Simulation}
\end{subfigure}

\caption{Prinzip der ergeignisbasierten Simulation bei zwei Parametern} 
\end{figure}
Wann ein Teilchen das nächste Mal seinen Zustand wechselt, wird mit Hilfe einer geometrisch verteilten Zufallszahl bestimmt. Daher lohnt sich diese Art der Simulation insbesondere bei Parametern nahe 1. 
Wenn ein Teilchen im aktuellen Schritt in den mobilen Zustand gewechsel hat, muss auch sein Ort angepasst werden. Da sich Teilchen eine Raumeinheit pro Zeitschritt bewegen, wird der Ort entsprechend der Zufallszahl erhöht.
TODO: Ort

Allerdings gestaltet sich das Testen auf Erreichen der Säulenlänge bei dieser Methode etwas schwieriger, da $l$ nur sehr selten genau getroffen wird. In vielen Fällen wird ein Teilchen von einem Ort kleiner $l$ direkt auf einen viel größeren Ort befördert. Daher muss zwischen jedem Simulationsschritt getestet werden, ob ein Teilchen bereits $l$ überschritten hat. Wenn das der Fall ist, muss mit Hilfe der Differenz zum aktuellen Simulationszeitpunkt die korrekte Ankunftszeit des Teilchens berechet werden.
Ob diese Berechnung nach jedem Simulationsschritt, also vor Neueintragung in die Liste geschieht, oder vor jedem Schritt, ist egal. Allerdings muss im zweiten Fall beachtet werden, dass, falls als Abbruchbedingung eine Maximalzeit gewählt wurde, sichergestellt sein muss, dass alle übrigen Teilchen noch einmal auf Erreichen von $l$ getestet werden.



\subsection{Simulation des 3-Zustände Modells}

Analog zum 2-Parameter Modell kann auch das 3-Zustände Modell schrittweise oder ereignisbasiert umgesetzt werden. Die Algorithmen \ref{algo_by_Step} und \ref{algo_by_event} bleiben jeweils unverändert, lediglich die Umsetzung der Simulation eines Schrittes bzw. einer Ereignisliste muss angepasst werden.

\subsubsection{Step-by-Step}
Weiterhin die neue Zustandsberechnung als logische Verknüpfung
Um aus Zufallszahlen die passenden Arrays mit größer/kleiner-Abfrage zu machen, erstelle kumulierte Wahrscheinlichkeiten (ein mal zu beginn)
Viele Hilfsarrays nötig, die entsprechend viel überflüssige Information enthalten
Erweiterung auf mehr Zustände mit exakt diesem Vorgehen wohl kaum sinnvoll, da zu zeitaufwändig. (TODO: Diskussionskapitel?)

\subsubsection{By-Event}
Bei dieser Simulationsart sind nur minimale Anpassungen notwendig. Es wird ein weiterer Zustand eingeführt und die Wahrscheinlichkeiten angepasst.
Da pro Schritt immer Zustandswechsel hier hilfsmatrix mit angepassten übergangswahrscheinlichkeiten, bei der die Wechselwahrscheinlichkeiten normiert 
werden


\section{PAA}

Zur Nutzung des PAA könnte man einfach die bereits vorhandene mosdi-Implementierung nutzen. Da diese jedoch mit steigender Säulenlänge deutlich langsamer wird \todo{Laufzeitverweis mosdi} wurde eine neue Herangehensweise gewählt. Diese zeichnet sich vor allem dadurch aus, dass einige nicht benötigte Funktionalitäten eines PAA nicht umgesetzt werden. 
Dies betrifft die Möglichkeit je Zustand mehrere verschiedene Emissionen mit einer jeweiligen Wahrsscheinlichkeit zuzulassen. Es wird, wie in \ref{PAA_2P} und TODO paa3s zu sehen ist, nur jeweils eine Wert mit der Wahrscheinlichkeit $1$ emittiert. Außerdem wird keine Möglichkeit weitere Operationen zuzulassen benötigt, Addition genügt. Da darüber hinaus nur im mobilen Zustand überhaupt eine Veränderung des Wertes erfolgt, wird der PAA auf diese Möglichkeit beschränkt.
Außerdem wird nicht jeweils die vollständige Zustands-Werte-Verteilung betrachtet, sondern nur der tatsächlich relevante Bereich. Dieser Bereich umfass zu Beginn einer Simulation lediglich die bereits erreichbaren Werte.
Für alle n<l ist n der maximal erreichbare Wert in schritt n
Außerdem werden Werte sehr nah bei 0 (<10hoch-17) ignoriert. Solche Werte werden aus der Verteilung gelöscht und die dadurch benötigten Arrays verkürzt, wodurch wiederum Simulationszeit eingespart wird.

%todo Wie werden die neuen Einträge berechnet? Graphik, Text dazu

% todo Wie werden die Arrays gekürzt

\subsection{PAA für das 2-Parameter Modell}

Ähnlich wie bei der Simulation der Teilchen 

\begin{figure}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=2cm,minimum height=1cm,font=\sffamily\scriptsize]

\begin{scope}[start chain=1 going right,node distance=-0.0mm]
    \node [on chain=1,feld,draw=none, font=\small] {stat.};
    \node [on chain=1,feld] (s1) {$s_1$};
    \node [on chain=1,feld] (s2) {$s_2$};
    \node [on chain=1,feld] {$s_3$};
    \node [on chain=1,feld] {$s_4$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}


\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-1.2cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {mob.};
    \node [on chain=1,feld] (m1) {$m_1$};
    \node [on chain=1,feld] (m2) {$m_2$};
    \node [on chain=1,feld] {$m_3$};
    \node [on chain=1,feld] {$m_4$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-2.6cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {s\_to\_s };
    \node [on chain=1,feld] (ss1) {$s_1*p_s$};
    \node [on chain=1,feld] (ss2) {$s_2*p_s$};
    \node [on chain=1,feld] {$s_3*p_s$};
    \node [on chain=1,feld] {$s_4*p_s$};
    \node [on chain=1,feld,align=center] {$0$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}
\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-3.8cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {s\_to\_m};
    \node [on chain=1,feld,align=center](sm1) {$0$};
    \node [on chain=1,feld] (sm1) {$s_1(1-p_s)$};
    \node [on chain=1,feld] (sm2) {$s_2(1-p_s)$};
    \node [on chain=1,feld] {$s_3(1-p_s)$};
    \node [on chain=1,feld] {$s_4(1-p_s)$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-5cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {m\_to\_m };
    \node [on chain=1,feld,align=center] {$0$};
    \node [on chain=1,feld] (mm1){$m_1*p_m$};
    \node [on chain=1,feld] (mm2){$m_2*p_m$};
    \node [on chain=1,feld] {$m_3*p_m$};
    \node [on chain=1,feld] {$m_4*p_m$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-6.2cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {m\_to\_s};
    \node [on chain=1,feld](ms1) {$s_1(1-p_s)$};
    \node [on chain=1,feld] (ms2){$s_2(1-p_s)$};
    \node [on chain=1,feld] {$s_3(1-p_s)$};
    \node [on chain=1,feld] {$s_4(1-p_s)$};
    \node [on chain=1,feld,align=center] {$0$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm, -7.6cm)}]
    \node [on chain=1,feld,draw=none, font=\small] {stat};
    \node [on chain=1,feld,align=center] (s'1) {$s_1*p_s +$\\$m_1(1-p_m)$};
    \node [on chain=1,feld,align=center](s'2) {$s_2*p_s +$\\$m_2(1-p_m)$};
    \node [on chain=1,feld,align=center] {$s_3*p_s +$\\$m_3(1-p_m)$};
    \node (n2) [on chain=1,feld,align=center] {$s_4*p_s +$\\$m_4(1-p_m)$};
    \node [on chain=1,feld,align=center] {$0$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}


\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-8.8cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node (n1) [on chain=1,feld,draw=none, font=\small] {mob};
    \node [on chain=1,feld] {$0$};
    \node [on chain=1,feld,align=center] (m'1){$m_1*p_m$\\$s_1(1-p_s)$};
    \node [on chain=1,feld,align=center] (m'2){$m_2*p_m$\\$s_4(1-p_s)$};
    \node [on chain=1,feld,align=center] {$m_3*p_m$\\$s_4(1-p_s)$};
    \node [on chain=1,feld,align=center] {$m_4*p_m$\\$s_4(1-p_s)$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}%         ;

\path [line width=1.4pt, line cap=rect, draw=blue!70!red, bend left=30](s1) edge (ss1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!70!red, bend left=30](ss1) edge (s'1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!50!white, bend right=30](m1) edge (ms1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!50!white, bend right=05](ms1) edge (s'1) ;

\path [line width=1.4pt, line cap=rect, draw=green!70!black, bend left=70](m2) edge (mm2) ;
\path [line width=1.4pt, line cap=rect, draw=green!70!black, bend left=40](mm2) edge (m'2) ;
\path [line width=1.4pt, line cap=rect, draw=green!40!yellow, bend right=10](s2) edge (sm2) ;
\path [line width=1.4pt, line cap=rect, draw=green!40!yellow, bend right=40](sm2) edge (m'2) ;

\end{tikzpicture}


\caption{PAA} \label{paa2p_prinzip}
\end{figure}

In \ref{paa2p_prinzip} ist exemplarisch dargestellt, wie die sich neuen Wahrscheinlichkeitsverteilungen in jedem Schritt berechnen. 
Gegeben sind die alten Wahrscheinlichkeitsverteilungen $stat$ und $mob$.
Um auf die neue Verteilung für den stationären Zustand zu kommen, muss für jede Position berechnet werden, welcher Anteil Teilchen stationär bleibt (s\_to\_s) und welcher Anteil bisher mobiler Teilchen in den stationären Zustand wechselt (m\_to\_s).
Analog müssen für die mobile Verteilung die mobil bleibenden sowie die sich aus dem Zustand lösenden Anteile berechnet werden. Da sich die Teilchen in der mobilen Phase jeweils einen Ort vorwärts bewegen, wird hier zusätzlich der ganze Vektor um ein Feld verschoben. Um eine anschließenden parallelen Berechnung der Wahrscheinlichkeiten der beiden Phasen durchführen zu können, wird zum Ausgleich den neu stationären Teilchenmassen ein neues Feld mit der Wahrscheinlichkeit von $0$ angehängt werden


\subsection{PAA für das 3-Zustände Modell}
Wie bei der schrittweisen Teilchensimulation tritt auch beim PAA für das 3-Zustände Modell das Problem auf, dass nicht mehr nur boolesche Werte  ausreichen, um den Zustand zu beschreiben. 

Erklaerung anschaulich auf dem Zettel vom 10.6.15


\section{Berechnung der Peakdaten}
Sowohl für die Simulation vieler Teilchen als auch bei der Verwendung eines PAA müssen nach der Simulation noch die Peakdaten berechnet werden. 

Bei den Teilchensimulationen liegen die Peaks als Liste von Ankuftszeiten vor, beim PAA hingegen als Anteil der Gesamtwahrscheinlichkeit zu jedem Zeitpunkt. 

Besonders bei den Teilchensimulationen ist es vorteilhaft, jeweils mehrere Zeitpunkte zusammen zu fassen, um die Peaks zu glätten.
\todo{Bild unzusammengefasster Daten zur Verdeutlichung?}

Maximalstelle: Am häufigsten vorkommende Ankunftszeit bzw. argmax der Wahrscheinlichkeiten

Breite und Schiefe: Jeweils Quartile berechnen und daraus IQR und IQK