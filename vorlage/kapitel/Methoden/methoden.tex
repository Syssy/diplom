\chapter{Methoden} 
\label{chapter:meth}

In diesem Kapitel werden für die verschiedenen Modelle Möglichkeiten beschrieben, diese zu simulieren. Offensichtlich ist es möglich, tatsächlich jeden einzelnen Zeitschritt für alle Teilchen zu betrachten. Wenn Zustandswechsel jedoch nicht sehr häufig vorkommen, kann es viel Zeit einsparen, nur zu relevanten Zeitpunkten, also für jeden Zustandswechsel, zu simulieren und dabei den Zeitpunkt des nächsten Wechsels zu notieren.

Im zweiten Abschitt des Kapitels wird beschieben, wie der PAA umgesetzt werden kann. Dabei liegt der Fokus auf einer eingeschränkten Variante des PAA, bei dem einige nicht benötigte Funktionalitäten, wie beispielsweise je Zustand verschiedene Operationen oder mehrere mögliche Emissionen, nicht berücksichtigt werden.

\section{Simulation}
Zunächst betrachten wir das in \ref{chapter:mod:2p} vorgestellte Modell mit nur zwei Zuständen und zwei Parametern, anschließend auch die in \ref{chapter:mod:3s} beschriebene Erweiterung auf 3 Zustände und damit bis zu 6 Parameter. Eine Unterscheidung zwischen Modell 3a und 3b findet hier nicht statt, sondern es werden beide zu einem allgemeinen Modell zusammen gefasst. Für die jeweilige Umsetzung müssen dann einfach die zwei nicht benötigten Übergangswahrscheinlichkeiten auf $0$ gesetzt werden.

Die Ankunftszeiten der simulierten Teilchen können dann als Peak aufgefasst und dargestellt werden. Außerdem werden daraus die resultierenden Peakdaten berechnet.
%Nach erfolgter Simulation können aus den Ankunftszeiten der Teilchen die Peakdaten der resultierenden Peaks berechnet werden.

\subsection{Simulation des 2-Zustände Modells}
Für das 2-Zustände Modell wurden zwei verschiedene Möglichkeiten der Simulation entworfen. Die erste, ``Step-by-Step'', simuliert schrittweise alle Zeitpunkte eines Säulendurchlaufs. Die zweite, ``By-Event'' verwaltet eine Liste relevanter Zeitpunkte, an denen Ereignisse - im konkreten Fall: Zustandswechsel - statt finden.

\subsubsection{Step-by-Step}
\begin{algorithm}
\caption{Ablauf der Step-by-Step Simulation}
\label{algo_by_Step}
\begin{algorithmic}
\REQUIRE Zustandsliste $z= [z_1 = 1, \ldots, z_n=1]$, Ortsliste $o=[o_1=1, \ldots , o_n=1]$, Zeit $t=0$, Maximalzeit $t_{max}$, Parameter $p_{\text{s}}$ und $p_{\text{m}}$
\ENSURE Ankuftszeiten $r$ oder FAIL
\WHILE{$t < t_{max}$ \AND $len(z) > 0$}
\FORALL {$p$}
\STATE Simuliere $p(p_s, p_{\text{m}})$
\IF {$o_p >l$}
\STATE $r \leftarrow t$
\STATE Lösche $z_p$ und $o_p$
\ENDIF
\ENDFOR
\STATE $t +=1$
\ENDWHILE
\IF {$len(z) > 0$}
\RETURN FAIL
\ELSE
\RETURN $r$
\ENDIF
\end{algorithmic}
\end{algorithm}

%\todo{Hinweis auf Parallelisierbarkeit und andere Zeitverbesserungen hier oder in Implementierung}

Der Ablauf einer schrittweisen Simulation ist in Algorithmus \ref{algo_by_Step} gegeben.

Simuliert werden $n$ Teilchen. Für jedes Teilchen $p$ muss jeweils der aktuelle Zustand $z_p$ und Ort $o_p$ festgehalten werden, außerdem muss in jedem Schritt der aktuelle Zeitpunkt $t$ vermerkt werden. Da nur zwei Zustände existieren und für alle p gilt $z_p \in \{0,1\}$ , bietet es sich an, dafür ein Array mit booleschen Werten zu verwenden. $0$ steht dabei für stationär und $1$ für mobil. Die Orte der Teilchen $o_p\in \{0, \ldots, l\}$ werden in einem weiteren Array festgehalten. Die Identifikation der Teilchen geschieht dabei über ihre Postition, die in beiden Arrays identisch ist.
%\todo{Array oder Vektor, bzw ohne Parallelisierbarkeit, da ja eigentlich nicht nötig?}
%Für jedes Teilchen wird in einem zweiten Array an gleicher Position sein aktueller Ort gespeichert. 

Simuliert wird, bis alle Teilchen das Säulenende erreicht haben, also die Vektoren eine Länge von $0$ haben. 
Als alternative Abbruchbedingung kann eine maximale Anzahl von Simulationsschritten gewählt werden, nach deren Ablauf die Simulation beendet ist, wenn nur Peaks von Interesse sind, die vor diesem Zeitpunkt im Chromatogramm erscheinen.

Es wird nun jeweils ein Zeitschritt für alle Teilchen simuliert. Nach jedem solchen Simulationsschritt wird getestet, ob Teilchen bereits den Wert von $l$ erreicht und damit die ganze Säule durchlaufen haben. Die entsprechende Anzahl dafür benötigter Schritte entspricht der Ankunftszeit der Teilchen und wird festgehalten, sodass als Ergebnis am Ende der Simulation eine Liste von Ankunftszeiten aller Teilchen entsteht. Teilchen, die angekommen sind, werden aus beiden Vektoren gelöscht.

Wenn die Simulation für alle Teilchen zu Ende geführt wurde, ist die Rückgabe die Liste der Ankunftszeiten aller Teilchen. Ansonsten gilt die Simulation als gescheitert, die Parameter $p_{\text{s}}$ und $p_{\text{m}}$ sorgen offenbar nicht für einen vollständigen Peak innerhalb des simulierten Zeitraumes.

Die Berechnung eines Simulationsschrittes läuft wie folgt: Die Teilchen wechseln in jedem Schritt mit einer bestimmten Wahrscheinlichkeit den Zustand. Diese sei wie in Kapitel \ref{chapter:mod} erwähnt, $p_{\text{m}}$ für das Verweilen in der mobilen Phase, $p_{\text{s}}$ für das Verweilen in der stationären Phase und $1-p_{\text{m}}$ bzw. $1-p_{\text{s}}$ für die beiden Möglichkeiten des Phasenwechsels. Daher muss pro Schritt und Teilchen eine Zufallszahl gezogen werden, anhand derer sich entscheidet, wie es sich verhält. Außerdem muss in jedem Schritt der Ort für jedes mobile Teilchen um eins erhöht werden.

Zum Ablauf der Simulation wurde entschieden, dass zunächst die Entscheidung über die Phase gefällt wird und sich die Teilchen anschließend gemäß ihres neuen Zustandes bewegen. Außerdem starten alle Teilchen ganz zu Beginn in der mobilen Phase, da sie nur so in das System eintreten können.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\fseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]

\begin{scope}[start chain =1 going right, node distance =0.0mm]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {Phasen $z$};
	\node [on chain=1, feld, fill=blue!30!white] (p1) {0};
	\node [on chain=1, feld] (p3) {0};
	\node [on chain=1, feld, fill=green!30!white] (p4) {1};
	\node [on chain=1, feld] (p5) {1};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (p6) {1};
	\node [on chain=1, feld] (p7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (p8) {0};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -1cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {Orte $o$};
	\node [on chain=1, feld] (o1) {0};
	\node [on chain=1, feld] (o3) {4};
	\node [on chain=1, feld] (o4) {4};
	\node [on chain=1, feld] (o5) {1};
	\node [on chain=1, feld] (o6) {6};
	\node [on chain=1, feld] (o7) {6};
	\node [on chain=1, feld] (o8) {3};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -2.5cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {ZV};
	\node [on chain=1, feld] (z1) {$0,9$};
	\node [on chain=1, feld] (z3) {$0,6$};
	\node [on chain=1, feld] (z4) {$0,2$};
	\node [on chain=1, feld] (z5) {$0,9$};
	\node [on chain=1, feld] (z6) {$0,7$};
	\node [on chain=1, feld] (z7) {$0,2$};
	\node [on chain=1, feld] (z8) {$0,7$};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -3.5cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {bleibe stat.: $s$};
	\node [on chain=1, feld, fill=blue!30!white] (ps1) {0};
	\node [on chain=1, feld] (ps3) {1};
	\node [on chain=1, feld] (ps4) {1};
	\node [on chain=1, feld] (ps5) {0};
	\node [on chain=1, feld] (ps6) {1};
	\node [on chain=1, feld] (ps7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (ps8) {1};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -4.5cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {bleibe mobil: $m$};
	\node [on chain=1, feld] (pm1) {0};
	\node [on chain=1, feld] (pm3) {0};
	\node [on chain=1, feld, fill=green!30!white] (pm4) {1};
	\node [on chain=1, feld] (pm5) {0};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (pm6) {0};
	\node [on chain=1, feld] (pm7) {1};
	\node [on chain=1, feld] (pm8) {0};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm, shift={(0cm, -6cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {Phasen $z'$};
	\node [on chain=1, feld, fill=blue!30!white] (np1) {1};
	\node [on chain=1, feld] (np3) {0};
	\node [on chain=1, feld, fill=green!30!white] (np4) {1};
	\node [on chain=1, feld] (np5) {0};
	\node [on chain=1, feld,fill=magenta!70!blue!20!white] (np6) {0};
	\node [on chain=1, feld] (np7) {1};
	\node [on chain=1, feld, fill=orange!30!white] (np8) {0};
\end{scope}

\begin{scope}[start chain =1 going right, node distance =0.0mm,shift={(0cm, -7cm)}]
	\node [on chain =1, feld, draw=none,minimum width=2.5cm] {Orte $o'$};
	\node [on chain=1, feld] (no1) {1};
	\node [on chain=1, feld] (no3) {4};
	\node [on chain=1, feld] (no4) {5};
	\node [on chain=1, feld] (no5) {1};
	\node [on chain=1, feld] (no6) {6};
	\node [on chain=1, feld] (no7) {7};
	\node [on chain=1, feld] (no8) {3};
\end{scope}

\end{tikzpicture}
\caption{Prinzip der schrittweisen Simulation mit den Parametern $p_s=0,8$, $p_{\text{m}}=0,5$}
\label{2p_by_step}
\end{figure}

In Abbildung \ref{2p_by_step} ist eine schematische Darstellung eines Simulationsschritts zu finden. Die angenommenen Wahrscheinlichkeiten für sind hier $p_{\text{s}} = 0,8$ und $p_{\text{m}} = 0,5$
Um eine parallele Bearbeitung aller Teilchen zu ermöglichen, soll nicht jeweils eine explizite Zustandsabfrage gemacht werden. Statt dessen werden für alle $n$ gezogenen Zufallszahlen die daraus resultierenden Übergänge für beide Zustände berechnet und in zwei Hilfsvektoren gespeichert, in $s$ wird jeweils vermerkt, ob ein Teilchen stationär bleibt und in $m$, ob es mobil bleibt, so es denn im jeweiligen Zustand war. Beispielsweise wurde für die violett und orange markierten Teilchen eine $0,7$ gezogen, was für mobile Teilchen wie das Violette bedeutet, dass sie den Zustand wechseln müssen, für stationäre Teilchen wie das Orangene jedoch, dass sie stationär bleiben. 
Dadurch, dass alle Übergänge vorberechnet wurden, werden die neuen Zustände über die Formel: $(z_p \land m_p) \lor (\lnot z_p \land \lnot s_p)$ berechnet. 

Für die neuen Orte kann einfach der neue Zustandsvektor auf den alten Ortsvektor addiert werden.

% Hier werden die Teilchen alle parallel bearbeitet 
% \todo{müsste hier nicht schon ein verweis auf numpy hin?}
% Um eine Abfrage des aktuellen Zustand zu sparen, wird einfach für beide Möglichkeiten berechnet. \todo{benennung der pspmvektoren}
% Dadurch können alle Zustandswechsel ebenfalls parallel  werden.

%\todo{Wo stehen Zeiteinheiten festgelegt -> Implementierung}


\subsubsection{By-Event}

\begin{algorithm}
\caption{Ablauf der by-Event Simulation}
\label{algo_by_event}
\begin{algorithmic}
\REQUIRE Eventliste $e= [e_0 = [(z_0, o_0), \ldots, (z_n, o_n)]]$ mit $z_p = 0, o_p = 0$ $\forall p$ , Zeit $t=0$, Maximalzeit $t_{max}$, Parameter $p_{\text{s}}$ und $p_{\text{m}}$
\ENSURE Ankuftszeiten $r$ oder FAIL
\WHILE{$t<t_{max}$ \AND Länge $e> 0$}
\FORALL {$(z_p, o_p)$ in $e[t]$}
\IF {$o_p > l$}
\STATE Berechne $t_a(p)$ 
\STATE $r \leftarrow t_a(p)$
\STATE Lösche $(z_p, o_p)$
\ELSE
\STATE Simuliere $(z_p, o_p)$
\STATE Aktualisiere $e$
\ENDIF
\ENDFOR
\STATE $t+=1$
\ENDWHILE
\IF {$len(e) > 0$}
\STATE Teste ausstehende Events
\STATE Entferne angekommene Teilchen
\IF {$len(e) > 0$}
\RETURN FAIL
\ENDIF
\ENDIF
\RETURN $r$
\end{algorithmic}
\end{algorithm}

Der Ablauf der ereignisbasierten Simulation ist in \ref{algo_by_event} angegeben.

% Dabei muss für jeden Zeitpunkt $t$ verwaltet werden, welche Teilchen zu diesem Zeitpunkt ihren Zustand wechseln. 
Auch hier werden $n$ Teilchen simuliert. Jedes davon besteht dabei aus seinem Ort und seinem Zustand. 
Zunächst starten alle Teilchen bei Zeitpunkt $0$, an Ort $0$ und stationär. Dadurch werden sie im ersten Simulationsschritt mobil und bewegen sich direkt fort. 
Im Gegensatz zur schrittweisen Simulation wird nun eine Liste mit Zeitpunkten verwaltet. Jeder Zeitpunkt beinhaltet eine Liste von Teilchen, die zu diesem Zeitpunkt simuliert werden müssen. Nach erfolger Simulation aller Teilchen der Liste, wird der Zeitpunkt gelöscht und der nächste Zeitpunkt, an dem etwas passieren soll, bearbeitet.

Simuliert wird auch hier bis entweder eine maximale Zeit erreicht ist oder alle Teilchen die gesamte Säule durchlaufen haben. Auch das Ergebnis ist wie bei der schrittweisen Simulation entweder eine Liste mit Ankunftszeiten aller Teilchen oder die Information, dass kein vollständiger Peak erreicht werden konnte.

% Ein Simulationsschritt behandelt dann alle Teilchen die zu einem Zeitpunkt ihren Zustand wecheln. 
% Ein solches Event beinhaltet den Wechsel des Zustands, die Bestimmung des Zeitpunkts des nächsten Zustandswechsels sowie bei mobilen Teilchen eine Änderung des Ortes. 

Ein Event beinhaltet alle Teilchen eines Zeitpunktes. Für jedes wird zunächst getestet, wo sich das Teilchen befindet. Falls es noch nicht das Säulenende erreicht hat, es simuliert. Diese Simulation umfasst den Wechsel des Zustands, die Bestimmung des Zeitpunkts des nächsten Zustandswechsels sowie bei mobilen Teilchen eine Änderung des Ortes um eine entsprechende Anzahl Schritte. Anschließend wird das Teilchen der Zeitpunkteliste seines nächsten Aktionszeitpunktes hinzugefügt.

Wann ein Teilchen das nächste Mal seinen Zustand wechselt, wird mit Hilfe einer geometrisch verteilten Zufallszahl mit Parameter $p=1-p_\text{s}$ bestimmt: Der nächste Zufallswechsel von Zustand $z$ nach $\neg z$ findet statt an Zeitpunkt $t= geom(1-p_{\text{s}})$ %\todo{ZZ ordentlich aufschreiben}.
Daher lohnt sich diese Art der Simulation insbesondere bei Parametern nahe 1. 
Wenn ein Teilchen im aktuellen Schritt in den mobilen Zustand gewechsel hat, muss auch sein Ort angepasst werden. Da sich Teilchen eine Raumeinheit pro Zeitschritt bewegen, wird der Ort entsprechend der gezogenen Zufallszahl erhöht.

Allerdings gestaltet sich das Testen auf Erreichen der Säulenlänge bei dieser Methode etwas schwieriger, da $l$ nur sehr selten genau getroffen wird. In vielen Fällen wird ein Teilchen von einem Ort kleiner $l$ direkt auf einen viel größeren Ort befördert. Daher muss zwischen jedem Simulationsschritt getestet werden, ob ein Teilchen bereits $l$ überschritten hat. Wenn das der Fall ist, muss mit Hilfe der Differenz zum aktuellen Simulationszeitpunkt die korrekte Ankunftszeit des Teilchens berechet werden.
Ob diese Berechnung nach jedem Simulationsschritt, also vor Neueintragung in die Liste geschieht, oder vor jedem Schritt, ist egal. Allerdings muss im zweiten Fall beachtet werden, dass, falls als Abbruchbedingung eine Maximalzeit gewählt wurde, sichergestellt sein muss, dass alle übrigen Teilchen noch einmal auf Erreichen von $l$ getestet werden.

\begin{figure}
\begin{subfigure}[t]{\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]

\begin{scope}[start chain =1 going right, node distance =-0.3mm]
	\node [on chain =1, feld, draw=none,minimum width=2cm] {Events $e$};
	\node [on chain=1, feld,minimum width=2cm] (p2) {$e_3$};
	\node [on chain=1, feld,minimum width=2cm] (p3) {$e_4$};
	\node [on chain=1, feld,minimum width=2cm] (p5) {$e_5$};
	\node [on chain=1, feld,minimum width=2cm] (p7) {$e_7$};
	\node [on chain=1, feld,minimum width=2cm] (p12) {$e_{12}$};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(2cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=green!50!white] (1x1) {$p_1 =(0,2)$};
	\node[on chain = 1, feld, fill=blue!40!white] (1x2) {$p_4 = (0, 1)$};
	\node[on chain = 1, feld, fill=orange!50!white] (1x3) {$p_7 = (1, 3)$};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(4cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (2x1) {($z_0, o_0$)};
	\node[on chain = 1, feld] (2x2) {($z_8, o_8$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(6cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (3x1) {($z_{10}, o_{10}$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(8cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (4x1) {($z_2, o_2$)};
	\node[on chain = 1, feld] (4x2) {($z_3, o_3$)};
	\node[on chain = 1, feld] (4x3) {($z_9, o_9$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(10cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (5x1) {($z_5, o_5$)};
\end{scope}

\path [line width=1.4pt, line cap=rect, draw](p2) edge (1x1) ;
\path [line width=1.4pt, line cap=rect, draw](1x1) edge (1x2) ;
\path [line width=1.4pt, line cap=rect, draw](1x2) edge (1x3) ;

\path [line width=1.4pt, line cap=rect, draw](p3) edge (2x1) ;
\path [line width=1.4pt, line cap=rect, draw](2x1) edge (2x2) ;

\path [line width=1.4pt, line cap=rect, draw](p5) edge (3x1) ;

\path [line width=1.4pt, line cap=rect, draw](p7) edge (4x1) ;
\path [line width=1.4pt, line cap=rect, draw](4x1) edge (4x2) ;
\path [line width=1.4pt, line cap=rect, draw](4x2) edge (4x3) ;

\path [line width=1.4pt, line cap=rect, draw](p12) edge (5x1) ;

\end{tikzpicture}
\caption{Vor der Simulation des Events $e_3$}
\label{2p_by_event_a}
\vspace*{5mm}
\end{subfigure}
\begin{subfigure}[b]{\textwidth}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=1.5cm,minimum height=0.7cm,font=\sffamily\footnotesize]

\begin{scope}[start chain =1 going right, node distance =-0.3mm]
	\node [on chain =1, feld, draw=none,minimum width=2cm] {Events $e$};
	\node [on chain=1, feld,minimum width=2cm] (p2) {$e_4$};
	\node [on chain=1, feld,minimum width=2cm] (p5) {$e_5$};
	\node [on chain=1, feld,minimum width=2cm] (p7) {$e_7$};
	\node [on chain=1, feld,minimum width=2cm] (p9) {$e_9$};
	\node [on chain=1, feld,minimum width=2cm] (p12) {$e_{12}$};
	\node [on chain=1, feld,minimum width=2cm] (p16) {$e_{16}$};
\end{scope}


\begin{scope}[start chain = 1 going below,shift={(2cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (2x1) {($z_0, o_0$)};
	\node[on chain = 1, feld] (2x2) {($z_8, o_8$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(4cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (5x1) {($z_{10}, o_{10}$)};
	\node[on chain = 1, feld, fill=green!50!white] (5x2) {$p_1 = (1,4)$};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(6cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (7x1) {($z_2, o_2$)};
	\node[on chain = 1, feld] (7x2) {($z_3, o_3$)};
	\node[on chain = 1, feld] (7x3) {($z_9, o_9$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(8cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=orange!50!white] (9x1) {$p_7 = (0, 3)$};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(10cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld] (12x1) {($z_5, o_5$)};
\end{scope}

\begin{scope}[start chain = 1 going below,shift={(12cm, -2cm)}, node distance=0.5cm]
	\node[on chain = 1, feld, fill=blue!40!white] (16x1) {$p_4 =(1, 14)$};
\end{scope}

%\path [line width=1.4pt, line cap=rect, draw](1x2) edge (1x3) ;

\path [line width=1.4pt, line cap=rect, draw](p2) edge (2x1) ;
\path [line width=1.4pt, line cap=rect, draw](2x1) edge (2x2) ;

\path [line width=1.4pt, line cap=rect, draw](p5) edge (5x1) ;
\path [line width=1.4pt, line cap=rect, draw](5x1) edge (5x2) ;

\path [line width=1.4pt, line cap=rect, draw](p7) edge (7x1) ;
\path [line width=1.4pt, line cap=rect, draw](7x1) edge (7x2) ;
\path [line width=1.4pt, line cap=rect, draw](7x2) edge (7x3) ;

\path [line width=1.4pt, line cap=rect, draw](p9) edge (9x1) ;

\path [line width=1.4pt, line cap=rect, draw](p12) edge (12x1) ;

\path [line width=1.4pt, line cap=rect, draw](p16) edge (16x1) ;

\end{tikzpicture}

\caption{Nach der Simulation}
\label{2p_by_event_b}
\end{subfigure}
\caption{Prinzip der ergeignisbasierten Simulation bei zwei Zuständen} 
\label{2p_by_event}
\end{figure}

In Abbildung \ref{2p_by_event} ist beispielhaft die Simulation eines Events gezeigt. Wie in \ref{2p_by_event_a} zu sehen, ist das nächste Event $e_3$. Es beinhaltet die Teilchen $p_1 = (z_1, o_1)$, $p_4 = (z_4, o_4)$ und $p_7 = (z_7, o_7)$. Keines der Teilchen hat bereits die Säulenlänge erreicht, sodass für alle ein Schritt simuliert wird. Gezogen werden die Zufallszahlen $x=2$, $y=13$ und $z=6$. Damit werden die Teilchen den Events $e_5$, $e_{16}$ und $e_9$ hinzugefügt. $p_{7}$ war mobil und geht nun in den stationären Zustand über. Deshalb ändert sich auch nichts an seinem Ort. $p_1$ und $p_4$ waren stationär und werden beide mobil. Darum muss ihr Ort noch um $2$ bzw. $13$ angepasst werden. Der Zustand der Zeitpunkteliste nach Abarbeitung der drei Teilchen ist in \ref{2p_by_event_b} abgebildet. Im nächsten Durchlauf wird das Event $e_4$ bearbeitet.

\subsection{Simulation des 3-Zustände Modells}

Analog zum 2-Zustände Modell kann auch das 3-Zustände Modell entweder schrittweise oder ereignisbasiert umgesetzt werden. Dafür bleiben die Algorithmen \ref{algo_by_Step} und \ref{algo_by_event} im Wesentlichen unverändert, lediglich die Umsetzung der Simulation eines Schrittes bzw. eines Zeitpunktes muss angepasst werden.

\subsubsection{Step-by-Step}

Durch die Hinzunahme eines weiteren Zustandes können nun nicht mehr boolesche Werte zur Zustandsbeschreibung herangezogen werden. Nun gilt Zustand $z \in \{0, 1, 2\}$  wobei $0$ für den mobilen Zustand steht, $1$ für die Adsorption und $2$ für die Lösung. Außerdem werden die Wahrscheinlichkeiten entsprechend auf eine Transitionsmatrix wie in \ref{3s_Transit} angepasst.

Um weiterhin eine logische Formel für die Zustandsberechnung nutzen zu können, sind viele Hilfsarrays nötig, die entsprechend viel überflüssige Information enthalten.

Um aus den gezogenen Zufallszahlen die passenden Arrays zu erstellen, aus denen die neuen Zustände berechnet werden können, wird zunächst eine Hilfstabelle mit den kumulierten Wahrscheinlichkeiten erstellt. %erstelle kumulierte Wahrscheinlichkeiten (ein mal zu beginn)

Beispiel:
$T= 
\begin{pmatrix}
0,5 & 0,3 & 0,2 \\
0,2 & 0,2 & 0,6 \\
0,15 & 0,15 & 0,7 
\end{pmatrix}
$  wird zu 
$K= 
\begin{pmatrix}
0,5 & 0,8 & 1 \\
0,2 & 0,4 & 1 \\
0,15 & 0,3 & 1 
\end{pmatrix}
$ 

In Abbildung \ref{3s_by_step_tabelle} ist der Ablauf der Simulation eines Zustandswechels für mehrere Teilchen exemplarisch zu sehen. Farblich markiert sind jeweils für einen gleichen Startzustand die relevanten Berechnungsschritte. Die Übergangswahrscheinlichkeiten entsprechen denen im obigen Beispiel.
Zunächst wird pro Zustand $z$ eine Maske $M_z$ erstellt, die eine $1$ an den Positionen enthält, an denen sich ein Teilchen in $z$ befindet. 

Außerdem wird analog zum 2-Zustände Modell jeweils aus den Zufallszahlen alle möglichen Übergänge berechnet. $U_{xy}$ steht dabei für den Übergang von Zustand $x$ nach Zustand $y$. Die Übergänge für $U_{x2}$ würden für alle $x$ auf Grund der kumulierten Wahrscheinlichkeiten nur Nulleinträge enthalten, daher können sie ausgelassen werden. 

Der neue Zustand eines Teilchens, das sich in Startzustand $x$ befindet, ergibt sich dann aus der Summe der beiden Arrays $U_{x0}$ und $U_{x1}$. Über diese Summe wird nun noch die passende Maske $M_x$ gelegt, damit jeweils nur der richtige Zielzustand für den Startzustand ausgewählt wird.
Dadurch entsteht pro Zustand ein Array, welches für jedes in diesem Zustand befindliche Teilchen den neuen Zustand nach dem Schritt beinhaltet. Diese Arrays brauchen nun nur noch kombiniert zu werden, um die Endzustände für alle Teilchen zu erhalten.
%\todo{Formulierung}

\begin{figure}
 \begin{tabular}{ l || l | l | l | l | l | l | l | l | l }
  \hline
  Startzustände & \cellcolor{orange!25}0 & \cellcolor{blue!25} 1 & \cellcolor{orange!25}0 & \cellcolor{green!25}2 & \cellcolor{green!25}2 & \cellcolor{blue!25} 1 & \cellcolor{orange!25}0 & \cellcolor{green!25}2 & \cellcolor{blue!25} 1 \\ \hline \hline 
  ZV & 0,3 & 0,9 & 0,7 & 0,8 & 0,2 & 0,1 & 0,9 & 0,1 & 0,3 \\ \hline \hline
  $M_0$ & \cellcolor{orange!25}1 & 0 & \cellcolor{orange!25}1 & 0 & 0 & 0 & \cellcolor{orange!25}1 & 0 & 0 \\ 
  $M_1$ & 0 & \cellcolor{blue!25}1 & 0 & 0 & 0 & \cellcolor{blue!25}1 & 0 & 0 & \cellcolor{blue!25}1 \\
  $M_2$ & 0 & 0 & 0 & \cellcolor{green!25}1 & \cellcolor{green!25}1 & 0 & 0 & \cellcolor{green!25}1 & 0 \\ \hline \hline
  $U_{00}$ & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ 
  $U_{01}$ & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
  $M_0\cdot (U_{00} + U_{01}$) & \cellcolor{orange!25}0 & 0 & \cellcolor{orange!25}1 & 0 & 0 & 0 & \cellcolor{orange!25}2 & 0 & 0 \\ \hline \hline
  $U_{10}$ & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\ 
  $U_{11}$ & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ \hline
  $M_1 \cdot (U_{10}+U_{11}$) & 0 & \cellcolor{blue!25}2 & 0 & 0 & 0 & \cellcolor{blue!25}0 & 0 & 0 & \cellcolor{blue!25}1 \\ \hline \hline
  $U_{20}$ & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 \\ 
  $U_{21}$ & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\ \hline
  $M_2\cdot (U_{20}+U_{21}$) & 0 & 0 & 0 & \cellcolor{green!25}2 & \cellcolor{green!25}1 & 0 & 0 & \cellcolor{green!25}0 & 0 \\ \hline \hline
  Endzustände & \cellcolor{orange!25}0 & \cellcolor{blue!25}2 & \cellcolor{orange!25}1 & \cellcolor{green!25}2 & \cellcolor{green!25}1 & \cellcolor{blue!25}0 & \cellcolor{orange!25}2 & \cellcolor{green!25}0 & \cellcolor{blue!25}1 \\ \hline
 \end{tabular}
\caption{Berechnung eines Zustandswechsels bei der schrittweisen Simulation im 3-Zustände Modell}
\label{3s_by_step_tabelle}
\end{figure}

Die Berechnung der neuen Orte der Teilchen ist dann wiederum einfach. Da die Maske für den mobilen Zustand bereits alle mobilen Teilchen markiert, kann diese auf den Ortsvektor addiert werden. Um $M_0$ nicht nach den Zustandswechseln neu berechnen zu müssen, findet das Fortbewegen im Simulationschritt vor dem Zustandswechsel statt und die Teilchen starten dafür an Position $0$ statt an $1$ wie es bei der 2-Zustände Simulation der Fall war.

\todo{Erweiterung auf mehr Zustände mit exakt diesem Vorgehen wohl kaum sinnvoll, da zu laufzeitintensiv-> Diskussionskapitel?}

\subsubsection{By-Event}
Bei dieser Simulationsart sind nur minimale Anpassungen notwendig. Wie in der Step-by-Step Simulation wird ein weiterer Zustand eingeführt, sodass $z_p \in \{0,1,2\}$ und die Wahrscheinlichkeiten werden angepasst.

Die Berechnung, wann ein Teilchen von Zustand $z$ in einen neuen Zustand $z'$ mit $z' \neq $ z wechselt, bleibt gleich, da sie nur vom aktuellen Zustand bzw. der Wahrscheinlichkeit in diesem Zustand zu bleiben abhängt. Unverändert bleibt auch die Bestimmung des neuen Ortes sowie der Test, ob ein Teilchen die Säule vollständig durchquert hat. 

Es muss lediglich eine Entscheidung, in welchen der beiden anderen Zustände das Teilchen wechselt, eingeführt werden. Ein Ereignis beinhaltet stets einen Zustandswechsel, also hat das Teilchen jeweils zwei mögliche Folgezustände. Die Übergangswahrscheinlichkeit von $z$ nach $z$ ist also immer $0$. Die Wahrscheinlichkeiten für die Wechsel in anderen beiden Zustände müssen entsprechend ihres Anteils an der Restwahrscheinlichkeit angepasst werden.

Dafür kann vorab eine Hilfsmatrix berechnet werden, in der sich die Wahrscheinlichkeiten für Folgezustände ablesen lassen.

\begin{equation}
\text{Wechselmatrix } W = 
\begin{pmatrix}
0 &  p_{ma}/1-p_{mm} & p_{ml}/1-p_{mm} \\
p_{am}/1- p_{aa} & 0 & p_{al}/1- p_{aa} \\
p_{lm}/1-p_{ll} &  p_{la}/1-p_{ll} & 0 
\end{pmatrix}  
\end{equation}

Aus der Transitionsmatrix

$T= 
\begin{pmatrix}
0,5 & 0,3 & 0,2 \\
0,2 & 0,2 & 0,6 \\
0,15 & 0,15 & 0,7 
\end{pmatrix}
$  
wird beispielsweise  
$W= 
\begin{pmatrix}
0 & 0,6 & 0,4 \\
0,25 & 0 & 0,75 \\
0,5 & 0,5 & 0 
\end{pmatrix}
$  

%\todo{soll der mod 3 kram noch rein?}
Nun muss nur noch eine weitere Zufallszahl gezogen werden, anhand derer sich mit Hilfe der Wechselmatrix der Folgezustand bestimmt.

%Wenn das Modell um weitere Zustände erweitert werden soll, kann auch die By-Event Simulation sehr einfach erweitert werden, da lediglich 

\section{PAA}

Zur Nutzung des PAA könnte man einfach die bereits vorhandene mosdi-Implementierung nutzen. Da diese jedoch mit steigender Säulenlänge deutlich langsamer wird \todo{Laufzeitverweis mosdi} wurde eine neue Herangehensweise gewählt. Hierbei werden einige nicht für das Modell benötigte Funktionalitäten eines PAA nicht umgesetzt. 

Dies betrifft die Möglichkeit je Zustand mehrere verschiedene Emissionen mit einer jeweiligen Wahrsscheinlichkeit zuzulassen. Es wird, wie in den Abbildungen \ref{PAA_2P} und \ref{3sPAA} zu sehen ist, nur jeweils ein Wert mit der Wahrscheinlichkeit $1$ emittiert. Außerdem wird keine Möglichkeit weitere Operationen zuzulassen benötigt, Addition genügt. Da darüber hinaus nur im mobilen Zustand überhaupt eine Veränderung des Wertes erfolgt, wird der PAA auf diese Möglichkeit beschränkt.
Außerdem wird nicht jeweils die vollständige Zustands-Werte-Verteilung betrachtet, sondern nur der tatsächlich relevante Bereich. Dieser Bereich umfass zu Beginn einer Simulation lediglich die bereits erreichbaren Werte.
Für alle n<l ist n der maximal erreichbare Wert in schritt n
Außerdem werden Werte sehr nah bei 0 (<10hoch-17) ignoriert. Solche Werte werden aus der Verteilung gelöscht und die dadurch benötigten Arrays verkürzt, wodurch wiederum Simulationszeit eingespart wird.

%todo Wie werden die neuen Einträge berechnet? Graphik, Text dazu

% todo Wie werden die Arrays gekürzt

\subsection{PAA für das 2-Zustände Modell}

Ähnlich wie bei der Simulation der Teilchen 

\begin{figure}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm,
  thick,main node/.style={circle,fill=white!20,draw,font=\sffamily\large\bfseries}]
\tikzstyle{feld}=[draw,minimum width=2cm,minimum height=1cm,font=\sffamily\scriptsize]

\begin{scope}[start chain=1 going right,node distance=-0.0mm]
    \node [on chain=1,feld,draw=none, font=\small] {stat.};
    \node [on chain=1,feld] (s1) {$z_1$};
    \node [on chain=1,feld] (s2) {$z_2$};
    \node [on chain=1,feld] {$z_3$};
    \node [on chain=1,feld] {$z_4$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}


\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-1.2cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {mob.};
    \node [on chain=1,feld] (m1) {$m_1$};
    \node [on chain=1,feld] (m2) {$m_2$};
    \node [on chain=1,feld] {$m_3$};
    \node [on chain=1,feld] {$m_4$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-2.6cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {s\_to\_{\text{s}} };
    \node [on chain=1,feld] (ss1) {$z_1\cdot p_{\text{s}}$};
    \node [on chain=1,feld] (ss2) {$z_2\cdot p_{\text{s}}$};
    \node [on chain=1,feld] {$z_3\cdot p_{\text{s}}$};
    \node [on chain=1,feld] {$z_4\cdot p_{\text{s}}$};
    \node [on chain=1,feld,align=center] {$0$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}
\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-3.8cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {s\_to\_{\text{m}}};
    \node [on chain=1,feld,align=center](sm1) {$0$};
    \node [on chain=1,feld] (sm1) {$z_1(1-p_{\text{s}})$};
    \node [on chain=1,feld] (sm2) {$z_2(1-p_{\text{s}})$};
    \node [on chain=1,feld] {$z_3(1-p_{\text{s}})$};
    \node [on chain=1,feld] {$z_4(1-p_{\text{s}})$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-5cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {m\_to\_{\text{m}} };
    \node [on chain=1,feld,align=center] {$0$};
    \node [on chain=1,feld] (mm1){$m_1\cdot p_{\text{m}}$};
    \node [on chain=1,feld] (mm2){$m_2\cdot p_{\text{m}}$};
    \node [on chain=1,feld] {$m_3\cdot p_{\text{m}}$};
    \node [on chain=1,feld] {$m_4\cdot p_{\text{m}}$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-6.2cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node [on chain=1,feld,draw=none, font=\small] {m\_to\_s};
    \node [on chain=1,feld](ms1) {$z_1(1-p_{\text{s}})$};
    \node [on chain=1,feld] (ms2){$z_2(1-p_{\text{s}})$};
    \node [on chain=1,feld] {$z_3(1-p_{\text{s}})$};
    \node [on chain=1,feld] {$z_4(1-p_{\text{s}})$};
    \node [on chain=1,feld,align=center] {$0$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}

\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm, -7.6cm)}]
    \node [on chain=1,feld,draw=none, font=\small] {stat};
    \node [on chain=1,feld,align=center] (s'1) {$z_1\cdot p_{\text{s}} +$\\$m_1(1-p_{\text{m}})$};
    \node [on chain=1,feld,align=center](s'2) {$z_2\cdot p_{\text{s}} +$\\$m_2(1-p_{\text{m}})$};
    \node [on chain=1,feld,align=center] {$z_3\cdot p_{\text{s}} +$\\$m_3(1-p_{\text{m}})$};
    \node (n2) [on chain=1,feld,align=center] {$z_4\cdot p_{\text{s}} +$\\$m_4(1-p_{\text{m}})$};
    \node [on chain=1,feld,align=center] {$0$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}


\begin{scope}[start chain=1 going right,node distance=-0.0mm, shift={(0cm,-8.8cm)},start chain=circle placed {at=(-\tikzchaincount*60:1.5)}]
    \node (n1) [on chain=1,feld,draw=none, font=\small] {mob};
    \node [on chain=1,feld] {$0$};
    \node [on chain=1,feld,align=center] (m'1){$m_1\cdot p_{\text{m}}$\\$z_1(1-p_{\text{s}})$};
    \node [on chain=1,feld,align=center] (m'2){$m_2\cdot p_{\text{m}}$\\$z_4(1-p_{\text{s}})$};
    \node [on chain=1,feld,align=center] {$m_3\cdot p_{\text{m}}$\\$z_4(1-p_{\text{s}})$};
    \node [on chain=1,feld,align=center] {$m_4\cdot p_{\text{m}}$\\$z_4(1-p_{\text{s}})$};
    \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1,feld,draw=none] {$\ldots$};
%     \node [on chain=1] {\textbf{Text}};
\end{scope}%         ;

\path [line width=1.4pt, line cap=rect, draw=blue!70!red, bend left=30](s1) edge (ss1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!70!red, bend left=30](ss1) edge (s'1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!50!white, bend right=30](m1) edge (ms1) ;
\path [line width=1.4pt, line cap=rect, draw=blue!50!white, bend right=05](ms1) edge (s'1) ;

\path [line width=1.4pt, line cap=rect, draw=green!70!black, bend left=70](m2) edge (mm2) ;
\path [line width=1.4pt, line cap=rect, draw=green!70!black, bend left=40](mm2) edge (m'2) ;
\path [line width=1.4pt, line cap=rect, draw=green!40!yellow, bend right=10](s2) edge (sm2) ;
\path [line width=1.4pt, line cap=rect, draw=green!40!yellow, bend right=40](sm2) edge (m'2) ;

\end{tikzpicture}
\caption{PAA}
\label{paa2p_prinzip}
\end{figure}

In \ref{paa2p_prinzip} ist exemplarisch dargestellt, wie die sich neuen Wahrscheinlichkeitsverteilungen in jedem Schritt berechnen. 
Gegeben sind die alten Wahrscheinlichkeitsverteilungen $stat$ und $mob$.
Um auf die neue Verteilung für den stationären Zustand zu kommen, muss für jede Position berechnet werden, welcher Anteil Teilchen stationär bleibt (s\_to\_s) und welcher Anteil bisher mobiler Teilchen in den stationären Zustand wechselt (m\_to\_s).
Analog müssen für die mobile Verteilung die mobil bleibenden sowie die sich aus dem Zustand lösenden Anteile berechnet werden. Da sich die Teilchen in der mobilen Phase jeweils einen Ort vorwärts bewegen, wird hier zusätzlich der ganze Vektor um ein Feld verschoben. Um eine anschließenden parallelen Berechnung der Wahrscheinlichkeiten der beiden Phasen durchführen zu können, wird zum Ausgleich den neu stationären Teilchenmassen ein neues Feld mit der Wahrscheinlichkeit von $0$ angehängt werden


\subsection{PAA für das 3-Zustände Modell}
Wie bei der schrittweisen Teilchensimulation tritt auch beim PAA für das 3-Zustände Modell das Problem auf, dass nicht mehr nur boolesche Werte  ausreichen, um den Zustand zu beschreiben. 

\todo {kommt diese berechnung nicht eher in die methoden?} %Transfer von modell 3s paa
Berechnung für nächsten Schritt '
Habe Matrix mit m, a, l und Orten 0...Länge mit den jeweiligen W'keiten
Neue Matrix:
$z^{'}_x(n) = z_{x-1}(1) \cdot  p_{1,n} + \sum^{|N|}_{m=2}{z_x(m) \cdot  p_{m,n}}$

Erklaerung anschaulich auf dem Zettel vom 10.6.15


\section{Berechnung der Peakdaten}
Sowohl für die Simulation vieler Teilchen als auch bei der Verwendung eines PAA müssen nach der Simulation noch die Peakdaten berechnet werden. 

Bei den Teilchensimulationen liegen die Peaks als Liste von Ankuftszeiten vor, beim PAA hingegen als Anteil der Gesamtwahrscheinlichkeit zu jedem Zeitpunkt. 

Besonders bei den Teilchensimulationen ist es vorteilhaft, jeweils mehrere Zeitpunkte zusammen zu fassen, um die Peaks zu glätten.
\todo{Bild unzusammengefasster Daten zur Verdeutlichung?}

Maximalstelle: Am häufigsten vorkommende Ankunftszeit bzw. argmax der Wahrscheinlichkeiten

Breite und Schiefe: Jeweils Quartile berechnen und daraus IQR und IQK